<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo do Senhor Bode - VersÃ£o HTML [VISUAL WOW UPGRADED]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #f4f4f4;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #game-container {
            width: 100%;
            min-height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            background: radial-gradient(circle at top, rgba(20, 28, 48, 0.65) 0%, rgba(4, 7, 15, 1) 65%);
            /* VISUAL WOW - Upgrade moderno aplicado */
        }

        #canvas-container {
            width: 100%;
            flex: 1 1 55%;
            min-height: 280px;
            position: relative;
            background: #04070f;
        }

        #canvas-container canvas {
            width: 100%;
            height: 100%;
        }

        #ui-container {
            width: 100%;
            flex: 1 1 45%;
            min-height: 320px;
            background: rgba(4, 4, 6, 0.75);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            padding: clamp(16px, 2.5vw, 28px);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: clamp(16px, 2vw, 28px);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.4);
        }

        #dialog-box {
            background: rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 20px;
            padding: 28px;
            margin-bottom: 20px;
            min-height: 120px;
            font-size: 18px;
            line-height: 1.75;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 215, 0, 0.1) inset,
                0 0 40px rgba(255, 215, 0, 0.15);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #dialog-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 215, 0, 0.6), 
                rgba(255, 215, 0, 0.9), 
                rgba(255, 215, 0, 0.6), 
                transparent
            );
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        #inventory {
            background: rgba(15, 20, 35, 0.6);
            backdrop-filter: blur(10px) saturate(150%);
            -webkit-backdrop-filter: blur(10px) saturate(150%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            padding: 18px;
            margin-bottom: 15px;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 215, 0, 0.1) inset;
            transition: all 0.3s ease;
        }

        #inventory:not(:has(.inventory-slot:empty)) {
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 215, 0, 0.2) inset,
                0 0 30px rgba(255, 215, 0, 0.2);
        }

        #inventory strong {
            color: #FFD700;
        }

        #inventory-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .inventory-slot {
            background: rgba(20, 30, 50, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 215, 0, 0.35);
            border-radius: 12px;
            padding: 10px 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.25s ease;
        }

        .inventory-slot:hover {
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.4),
                0 4px 16px rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }

        .inventory-icon {
            font-size: 28px;
            line-height: 1;
        }

        .inventory-labels {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .inventory-name {
            font-weight: bold;
        }

        .inventory-details {
            font-size: 12px;
            opacity: 0.8;
        }

        .inventory-count {
            position: absolute;
            top: -6px;
            right: -6px;
            background: linear-gradient(135deg, #ff9a3c 0%, #ff4e50 100%);
            color: #fff;
            border-radius: 50%;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 78, 80, 0.4);
        }

        #inventory-empty {
            font-size: 13px;
            opacity: 0.75;
        }

        #choices-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-button {
            background: linear-gradient(135deg, 
                rgba(102, 126, 234, 0.8) 0%, 
                rgba(118, 75, 162, 0.9) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            color: white;
            padding: 16px 28px;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 215, 0, 0.2) inset,
                0 0 30px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        .choice-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent
            );
            transition: left 0.5s;
        }

        .choice-button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 215, 0, 0.4) inset,
                0 0 50px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, 
                rgba(118, 75, 162, 0.9) 0%, 
                rgba(102, 126, 234, 0.95) 100%);
            border-color: rgba(255, 215, 0, 0.7);
        }

        .choice-button:hover::before {
            left: 100%;
        }

        .choice-button:active {
            transform: translateY(-2px) scale(1.0);
        }

        #stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #FFD700;
        }

        .stat-label {
            color: #FFD700;
            font-weight: bold;
        }

        #hunger-bar {
            width: 160px;
            height: 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 6px;
        }

        #hunger-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #5cff6f 0%, #ffd54f 50%, #ff4e4e 100%);
            transition: width 0.3s ease;
        }

        #hunger-value {
            font-size: 12px;
            margin-top: 4px;
            opacity: 0.75;
        }

        #title-screen {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(22, 28, 46, 0.88) 0%, rgba(3, 6, 12, 0.97) 70%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: clamp(20px, 4vw, 48px);
            backdrop-filter: blur(2px);
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(1.05);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        #title-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(20px, 4vw, 48px);
            max-width: min(960px, 100%);
        }

        #title-hero {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(24px, 5vw, 56px);
            flex-wrap: wrap;
            width: 100%;
        }

        #title-image {
            width: clamp(220px, 28vw, 360px);
            max-width: 100%;
            height: auto;
            filter: drop-shadow(0 16px 32px rgba(0, 0, 0, 0.6));
        }

        #title-text {
            display: flex;
            flex-direction: column;
            gap: clamp(16px, 3vw, 28px);
            text-align: left;
            max-width: 420px;
        }

        #title-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(42px, 6vw, 72px);
            font-weight: 900;
            letter-spacing: clamp(4px, 1vw, 14px);
            text-transform: uppercase;
            color: #fafafa;
            text-shadow: 
                0 0 20px rgba(255, 255, 255, 0.4),
                0 0 40px rgba(255, 215, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.5);
            animation: titleGlow 3.5s infinite;
            background: linear-gradient(135deg, #ffffff 0%, #ffd700 50%, #ffffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% 200%;
            animation: titleGlow 3.5s infinite, gradientShift 4s ease infinite;
        }

        @keyframes titleGlow {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                filter: brightness(1);
            }
            20%, 24%, 55% {
                filter: brightness(0.6);
            }
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
            }
            20%, 24%, 55% {
                opacity: 0.4;
            }
        }

        #title-tagline {
            font-size: clamp(18px, 2.5vw, 24px);
            line-height: 1.5;
            letter-spacing: clamp(1px, 0.6vw, 4px);
            opacity: 0.9;
            text-transform: uppercase;
        }

        #title-description {
            font-size: clamp(16px, 2vw, 20px);
            line-height: 1.6;
            color: rgba(240, 240, 240, 0.85);
        }

        #start-button {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.15) 0%, 
                rgba(255, 165, 0, 0.2) 50%,
                rgba(255, 215, 0, 0.15) 100%);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 2px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 20px 56px;
            font-size: clamp(18px, 2vw, 22px);
            font-weight: 700;
            letter-spacing: clamp(3px, 0.8vw, 5px);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 215, 0, 0.2) inset,
                0 0 40px rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        #start-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #start-button:hover {
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.25) 0%, 
                rgba(255, 165, 0, 0.35) 50%,
                rgba(255, 215, 0, 0.25) 100%);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 215, 0, 0.4) inset,
                0 0 60px rgba(255, 215, 0, 0.5);
            transform: translateY(-4px) scale(1.05);
            border-color: rgba(255, 215, 0, 0.8);
        }

        #start-button:hover::before {
            width: 300px;
            height: 300px;
        }

        #start-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        #title-instructions {
            font-size: clamp(13px, 1.4vw, 15px);
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.65);
            text-align: center;
        }

        #title-instructions strong {
            color: #FFD700;
        }

        @media (max-width: 1080px) {
            #ui-container {
                min-height: 280px;
            }

            #stats {
                flex-wrap: wrap;
                gap: 14px;
            }
        }

        @media (max-width: 820px) {
            #game-container {
                min-height: 100dvh;
            }

            #canvas-container {
                min-height: 220px;
                flex: 1 1 50%;
            }

            #ui-container {
                flex: 1 1 50%;
                padding: clamp(16px, 5vw, 24px);
                gap: clamp(14px, 3vw, 24px);
            }

            #title-hero {
                flex-direction: column;
                text-align: center;
            }

            #title-text {
                text-align: center;
                align-items: center;
            }
        }

        @media (max-width: 560px) {
            body {
                font-size: 14px;
            }

            #title-screen h1 {
                font-size: clamp(34px, 10vw, 42px);
            }

            #title-tagline {
                letter-spacing: clamp(0.5px, 1vw, 2px);
            }

            #start-button {
                width: min(320px, 85vw);
                padding: 14px 20px;
            }

            #title-instructions {
                letter-spacing: 1px;
            }

            #dialog-box {
                font-size: 16px;
                padding: 18px;
            }

            .choice-button {
                padding: 12px 18px;
                font-size: 15px;
            }
        }

        .hidden {
            display: none !important;
        }

        /* Tela de Morte */
        #death-screen {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(46, 22, 22, 0.95) 0%, rgba(12, 3, 3, 0.98) 70%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: clamp(20px, 4vw, 48px);
            backdrop-filter: blur(8px);
            animation: fadeInDeath 0.6s ease-out;
        }

        @keyframes fadeInDeath {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        #death-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(24px, 5vw, 40px);
            max-width: min(800px, 90%);
            text-align: center;
        }

        #death-title {
            font-size: clamp(48px, 7vw, 80px);
            color: #ff4444;
            text-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
            margin: 0;
            animation: pulse 2s infinite;
        }

        #death-reason {
            font-size: clamp(20px, 3vw, 32px);
            color: #ffaaaa;
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(20px, 4vw, 32px);
            border-radius: 12px;
            border: 2px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            line-height: 1.6;
            max-width: 100%;
        }

        #restart-button {
            font-family: 'Orbitron', sans-serif;
            padding: clamp(16px, 2.5vw, 22px) clamp(36px, 5vw, 56px);
            font-size: clamp(18px, 2.5vw, 24px);
            background: linear-gradient(135deg, 
                rgba(255, 68, 68, 0.9) 0%, 
                rgba(204, 34, 34, 0.95) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 2px solid rgba(255, 68, 68, 0.6);
            border-radius: 14px;
            cursor: pointer;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 6px 24px rgba(255, 68, 68, 0.4),
                0 0 0 1px rgba(255, 68, 68, 0.2) inset,
                0 0 40px rgba(255, 68, 68, 0.3);
            position: relative;
            overflow: hidden;
        }

        #restart-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #restart-button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 
                0 10px 32px rgba(255, 68, 68, 0.6),
                0 0 0 1px rgba(255, 68, 68, 0.4) inset,
                0 0 60px rgba(255, 68, 68, 0.5);
            border-color: rgba(255, 68, 68, 0.8);
        }

        #restart-button:hover::before {
            width: 300px;
            height: 300px;
        }

        #restart-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        /* Tela de VitÃ³ria */
        #victory-screen {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(22, 46, 22, 0.95) 0%, rgba(3, 12, 3, 0.98) 70%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: clamp(20px, 4vw, 48px);
            backdrop-filter: blur(8px);
            animation: fadeInVictory 0.8s ease-out;
        }

        @keyframes fadeInVictory {
            from {
                opacity: 0;
                transform: scale(1.05);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        #victory-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(24px, 5vw, 40px);
            max-width: min(800px, 90%);
            text-align: center;
        }

        #victory-title {
            font-size: clamp(56px, 8vw, 96px);
            color: #44ff44;
            text-shadow: 0 0 40px rgba(68, 255, 68, 0.7);
            margin: 0;
            animation: pulse 2s infinite;
        }

        #victory-message {
            font-size: clamp(22px, 3.5vw, 36px);
            color: #aaffaa;
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(20px, 4vw, 32px);
            border-radius: 12px;
            border: 2px solid #44ff44;
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.4);
            line-height: 1.6;
            max-width: 100%;
        }

        #victory-restart-button {
            padding: clamp(14px, 2.5vw, 20px) clamp(32px, 5vw, 48px);
            font-size: clamp(18px, 2.5vw, 24px);
            background: linear-gradient(135deg, #44ff44 0%, #22cc22 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(68, 255, 68, 0.4);
        }

        #victory-restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(68, 255, 68, 0.6);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Tela de TÃ­tulo -->
        <div id="title-screen">
            <div id="title-content">
                <div id="title-hero">
                    <img id="title-image" src="./assets/img/srbode.png" alt="IlustraÃ§Ã£o do personagem Senhor Bode">
                    <div id="title-text">
                        <h1>Jogo do Senhor Bode</h1>
                        <p id="title-tagline">A jornada lendÃ¡ria comeÃ§a agora</p>
                        <p id="title-description">
                            Explore a floresta, faÃ§a escolhas estratÃ©gicas e descubra onde o Senhor Bode se esconde. Cada decisÃ£o aproxima ou afasta vocÃª do final perfeito.
                        </p>
                    </div>
                </div>
                <button id="start-button" onclick="startGame()">ðŸš€ Iniciar Jornada</button>
                <div id="title-instructions">
                    <strong>Toque</strong> na tela ou <strong>clique</strong> para comeÃ§ar
                </div>
            </div>
        </div>

        <!-- Tela de Morte -->
        <div id="death-screen" class="hidden">
            <div id="death-content">
                <h1 id="death-title">ðŸ’€ VocÃª Morreu</h1>
                <div id="death-reason"></div>
                <button id="restart-button" onclick="reiniciarJogo()">ðŸ”„ Reiniciar Jogo</button>
            </div>
        </div>

        <!-- Tela de VitÃ³ria -->
        <div id="victory-screen" class="hidden">
            <div id="victory-content">
                <h1 id="victory-title">ðŸŽ‰ ParabÃ©ns!</h1>
                <p id="victory-message">VocÃª completou a jornada e derrotou o Senhor Bode!</p>
                <button id="victory-restart-button" onclick="reiniciarJogo()">ðŸ”„ Reiniciar Jogo</button>
            </div>
        </div>

        <!-- Container do Canvas 3D -->
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>

        <!-- Interface do UsuÃ¡rio -->
        <div id="ui-container">
            <div id="stats" class="hidden">
                <div class="stat">
                    <span class="stat-label" id="distance-label">DistÃ¢ncia:</span> <span id="distance-value">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label" id="proximity-label">Proximidade Bode:</span> <span id="proximity-value">0</span>
                </div>
                <div class="stat hidden" id="hunger-stat">
                    <span class="stat-label">Fome</span>
                    <div id="hunger-bar"><div id="hunger-fill"></div></div>
                    <div id="hunger-value">100%</div>
                </div>
            </div>

            <div id="inventory" class="hidden">
                <strong>InventÃ¡rio:</strong>
                <div id="inventory-empty">Nenhum item</div>
                <div id="inventory-items"></div>
            </div>

            <div id="dialog-box">
                Bem-vindo ao Jogo do Senhor Bode! Clique em "INICIAR JOGO" para comeÃ§ar.
            </div>

            <div id="choices-container">
                <!-- BotÃµes de escolha aparecerÃ£o aqui -->
            </div>
        </div>
    </div>

    <script>
        // Estado do jogo
        const gameState = {
            inventario: [],
            proximidade_sr_bode: 0,
            distancia_cidade: 0,
            cena_atual: 'floresta',
            scene: null,
            camera: null,
            renderer: null,
            player: null,
            playerState: 'idle',
            activeUpdate: null,
            ambientAtual: null,
            audioUnlocked: false,
            cameraAnimation: null,
            isCameraAnimating: false,
            loboChamou: false,
            bodeNoMercado: false,
            fome: 100,
            lastCansacoSound: 0,
            comodosExplorados: 0,
            isRunning: false,
            festaAconteceu: false
        };

        const sceneHelpers = {
            clock: null,
            reusable: {},
            loopStarted: false
        };

        function resetGameProgress() {
            gameState.inventario = [];
            gameState.proximidade_sr_bode = 0;
            gameState.distancia_cidade = 0;
            gameState.cena_atual = 'floresta';
            gameState.playerState = 'idle';
            gameState.activeUpdate = null;
            gameState.ambientAtual = null;
            gameState.cameraAnimation = null;
            gameState.isCameraAnimating = false;
            gameState.loboChamou = false;
            gameState.bodeNoMercado = false;
            gameState.fome = 100;
            gameState.lastCansacoSound = 0;
            gameState.comodosExplorados = 0;
            gameState.isRunning = false;
            gameState.festaAconteceu = false;
        }

        function reiniciarJogo() {
            // Esconder telas de morte e vitÃ³ria
            document.getElementById('death-screen').classList.add('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
            document.getElementById('title-screen').classList.add('hidden');
            
            setTimeout(() => {
                startGame();
            }, 500);
        }

        function mostrarTelaMorte(motivo) {
            document.getElementById('death-reason').textContent = motivo;
            document.getElementById('death-screen').classList.remove('hidden');
            document.getElementById('ui-container').style.display = 'none';
        }

        function mostrarTelaVitoria() {
            document.getElementById('victory-screen').classList.remove('hidden');
            document.getElementById('ui-container').style.display = 'none';
        }

        const CAMERA_FORWARD = new THREE.Vector3(0, 0, -1);
        const CAMERA_UP = new THREE.Vector3(0, 1, 0);

        function setCameraPose(position, target, smooth = false) {
            if (!gameState.camera) return;
            const camera = gameState.camera;
            const pos = position.clone();
            let destTarget = target.clone();
            let direction = destTarget.clone().sub(pos);
            if (direction.lengthSq() < 1e-6) {
                direction = CAMERA_FORWARD.clone();
                destTarget = pos.clone().add(direction);
            }
            direction.normalize();
            const quaternion = new THREE.Quaternion().setFromUnitVectors(CAMERA_FORWARD, direction);

            // InterpolaÃ§Ã£o suave (lerp) para movimentos cinematogrÃ¡ficos
            if (smooth && camera.userData.lastPosition && camera.userData.lastTarget) {
                const lerpFactor = 0.1; // Ajuste para velocidade de interpolaÃ§Ã£o
                camera.position.lerp(pos, lerpFactor);
                const currentTarget = camera.userData.lastTarget.clone();
                currentTarget.lerp(destTarget, lerpFactor);
                const smoothDirection = currentTarget.clone().sub(camera.position).normalize();
                const smoothQuaternion = new THREE.Quaternion().setFromUnitVectors(CAMERA_FORWARD, smoothDirection);
                camera.quaternion.slerp(smoothQuaternion, lerpFactor);
            } else {
                camera.position.copy(pos);
                camera.quaternion.copy(quaternion);
            }
            
            camera.up.copy(CAMERA_UP);
            camera.updateMatrixWorld(true);

            if (!camera.userData) camera.userData = {};
            camera.userData.lastPosition = camera.position.clone();
            camera.userData.lastLookAt = destTarget.clone();
            camera.userData.lastTarget = destTarget.clone();
        }

        function getCameraLookAt() {
            if (!gameState.camera) return new THREE.Vector3(0, 0, -1);
            const stored = gameState.camera.userData?.lastTarget || gameState.camera.userData?.lastLookAt;
            if (stored) {
                return stored.clone();
            }
            const forward = CAMERA_FORWARD.clone().applyQuaternion(gameState.camera.quaternion);
            return gameState.camera.position.clone().add(forward);
        }

        function updateCameraLookAt(target) {
            if (!gameState.camera) return;
            setCameraPose(gameState.camera.position.clone(), target);
        }

        function easingFunction(name) {
            switch (name) {
                case 'easeInCubic':
                    return (t) => t * t * t;
                case 'easeOutCubic':
                    return (t) => 1 - Math.pow(1 - t, 3);
                case 'easeInOutSine':
                    return (t) => -(Math.cos(Math.PI * t) - 1) / 2;
                case 'easeInOutCubic':
                default:
                    return (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
            }
        }

        function startCameraAnimation(keyframes, options = {}) {
            if (!gameState.camera) return Promise.resolve();
            if (!Array.isArray(keyframes) || keyframes.length < 2) {
                return Promise.resolve();
            }

            const duration = options.duration || 2.5;
            const easing = easingFunction(options.easing || 'easeInOutCubic');
            const frames = keyframes.map((frame) => ({
                position: frame.position.clone(),
                lookAt: frame.lookAt.clone()
            }));

            return new Promise((resolve) => {
                gameState.cameraAnimation = {
                    keyframes: frames,
                    duration,
                    elapsed: 0,
                    easing,
                    resolve
                };
                gameState.isCameraAnimating = true;
            });
        }

        function updateCameraAnimation(delta) {
            const anim = gameState.cameraAnimation;
            if (!anim) return;

            anim.elapsed += delta;
            const rawProgress = Math.min(anim.elapsed / anim.duration, 1);
            const eased = anim.easing ? anim.easing(rawProgress) : rawProgress;

            const segmentCount = anim.keyframes.length - 1;
            if (segmentCount <= 0) {
                if (anim.resolve) anim.resolve();
                gameState.cameraAnimation = null;
                gameState.isCameraAnimating = false;
                return;
            }

            const scaled = eased * segmentCount;
            const index = Math.min(Math.floor(scaled), segmentCount - 1);
            const localT = scaled - index;
            const from = anim.keyframes[index];
            const to = anim.keyframes[index + 1];

            const newPosition = new THREE.Vector3().lerpVectors(from.position, to.position, localT);
            const newLook = new THREE.Vector3().lerpVectors(from.lookAt, to.lookAt, localT);

            setCameraPose(newPosition, newLook);

            if (rawProgress >= 1) {
                const resolve = anim.resolve;
                gameState.cameraAnimation = null;
                gameState.isCameraAnimating = false;
                if (gameState.scene) {
                    gameState.scene.userData = gameState.scene.userData || {};
                    gameState.scene.userData.cameraBase = newPosition.clone();
                    gameState.scene.userData.cameraLook = newLook.clone();
                }
                if (resolve) resolve();
            }
        }

        function animateFirstPersonMove(points, options = {}) {
            if (!gameState.camera) return Promise.resolve();
            const keyframes = [];
            const currentPos = gameState.camera.position.clone();
            const currentLook = getCameraLookAt();

            keyframes.push({
                position: currentPos.clone(),
                lookAt: currentLook.clone()
            });

            if (Array.isArray(points)) {
                points.forEach((frame) => {
                    if (!frame) return;
                    const position = frame.position ? frame.position.clone() : currentPos.clone();
                    const lookAt = frame.lookAt ? frame.lookAt.clone() : currentLook.clone();
                    keyframes.push({ position, lookAt });
                });
            }

            if (keyframes.length < 2) {
                return Promise.resolve();
            }

            return startCameraAnimation(keyframes, options);
        }

        function getSceneCameraBase() {
            const scene = gameState.scene;
            const base = scene?.userData?.cameraBase ? scene.userData.cameraBase.clone() : gameState.camera?.position.clone() || new THREE.Vector3();
            const look = scene?.userData?.cameraLook ? scene.userData.cameraLook.clone() : getCameraLookAt();
            return { base, look };
        }

        function playActionNod(strength = 0.4, duration = 1.1) {
            if (!gameState.camera) return Promise.resolve();
            const originPos = gameState.camera.position.clone();
            const look = getCameraLookAt();
            const forward = look.clone().sub(originPos);
            forward.y = 0;
            if (forward.lengthSq() === 0) {
                forward.set(0, 0, -1);
            }
            forward.normalize();
            const offset = forward.clone().multiplyScalar(strength);
            const up = new THREE.Vector3(0, 1, 0);
            return animateFirstPersonMove([
                {
                    position: originPos.clone().add(offset.clone().multiplyScalar(0.6)).add(up.clone().multiplyScalar(0.06)),
                    lookAt: look.clone().add(offset.clone())
                },
                {
                    position: originPos.clone(),
                    lookAt: look.clone()
                }
            ], { duration });
        }

        const ITEM_DEFS = {
            'Comida': {
                icon: 'ðŸ¥ª',
                name: 'Comida',
                detail: 'Energia extra',
                color: '#ffb347'
            },
            'Mapa': {
                icon: 'ðŸ—ºï¸',
                name: 'Mapa',
                detail: 'Atalhos revelados',
                color: '#7ed957'
            },
            'Escopeta': {
                icon: 'ðŸ”«',
                name: 'Escopeta',
                detail: 'Nada o detÃ©m',
                color: '#b3b3b3'
            },
            'SabÃ£o Macaco': {
                icon: 'ðŸ§¼',
                name: 'SabÃ£o Macaco',
                detail: 'Atraso garantido',
                color: '#a0e7e5'
            },
            'Medo extremo': {
                icon: 'ðŸ˜±',
                name: 'Medo extremo',
                detail: 'Alerta constante',
                color: '#ff6b6b'
            }
        };

        const audioManager = {
            context: null,
            ambientGain: null,
            effectGain: null,
            ambientSource: null,
            playingAmbient: null,
            unlocked: false,
            init() {
                if (this.context) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtx) {
                    console.warn('Web Audio API nÃ£o suportada');
                    return;
                }
                this.context = new AudioCtx();
                this.ambientGain = this.context.createGain();
                this.effectGain = this.context.createGain();
                this.ambientGain.gain.value = 0.2;
                this.effectGain.gain.value = 0.4;
                this.ambientGain.connect(this.context.destination);
                this.effectGain.connect(this.context.destination);
            },
            async resume() {
                this.init();
                if (!this.context) {
                    this.unlocked = false;
                    return;
                }
                if (this.context && this.context.state === 'suspended') {
                    await this.context.resume();
                }
                this.unlocked = true;
            },
            stopAmbient() {
                if (this.ambientSource) {
                    try {
                        this.ambientSource.stop();
                    } catch (e) {
                        console.warn(e);
                    }
                    this.ambientSource.disconnect();
                    this.ambientSource = null;
                }
                this.playingAmbient = null;
            },
            playAmbient(type) {
                if (!this.unlocked) return;
                if (this.playingAmbient === type) return;
                this.stopAmbient();
                if (!this.context) return;

                const buffer = this.createAmbientBuffer(type);
                if (!buffer) return;
                const source = this.context.createBufferSource();
                source.buffer = buffer;
                source.loop = true;
                source.connect(this.ambientGain);
                source.start(0);
                this.ambientSource = source;
                this.playingAmbient = type;
            },
            playEffect(type) {
                if (!this.unlocked) return;
                if (!this.context) return;
                const buffer = this.createEffectBuffer(type);
                if (!buffer) return;
                const source = this.context.createBufferSource();
                source.buffer = buffer;
                source.connect(this.effectGain);
                source.start(0);
            },
            createAmbientBuffer(type) {
                if (!this.context) return null;
                const sampleRate = this.context.sampleRate;
                const length = sampleRate * 4;
                const buffer = this.context.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    if (type === 'floresta') {
                        const noise = (Math.random() * 2 - 1) * 0.2;
                        const wind = Math.sin(t * 0.6) * 0.08;
                        const crickets = Math.sin(2 * Math.PI * 5 * t) * Math.sin(2 * Math.PI * 0.5 * t);
                        data[i] = noise + wind + crickets * 0.12;
                    } else if (type === 'cabana') {
                        const fire = (Math.random() * 2 - 1) * 0.15;
                        const base = Math.sin(t * 1.2) * 0.05;
                        data[i] = fire + base;
                    } else if (type === 'fuga') {
                        const pulse = Math.sin(2 * Math.PI * 1.2 * t) * 0.15;
                        const noise = (Math.random() * 2 - 1) * 0.12;
                        data[i] = pulse + noise;
                    } else {
                        data[i] = 0;
                    }
                }

                return buffer;
            },
            createEffectBuffer(type) {
                if (!this.context) return null;
                const sampleRate = this.context.sampleRate;
                let length = sampleRate * 0.4;
                if (type === 'passo') length = sampleRate * 0.18;
                if (type === 'escopeta') length = sampleRate * 0.8;
                if (type === 'cansado') length = sampleRate * 1.2;
                const buffer = this.context.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-6 * t);
                    let sample = 0;
                    if (type === 'coleta') {
                        sample = Math.sin(2 * Math.PI * 800 * t) * envelope;
                    } else if (type === 'perigo') {
                        sample = Math.sin(2 * Math.PI * 160 * t) * envelope * 0.8;
                    } else if (type === 'usar') {
                        sample = Math.sin(2 * Math.PI * 520 * t) * envelope * 0.7;
                    } else if (type === 'passo') {
                        sample = ((Math.random() * 2 - 1) * 0.4 + Math.sin(2 * Math.PI * 60 * t) * 0.3) * envelope;
                    } else if (type === 'escopeta') {
                        const blastEnvelope = Math.exp(-8 * t);
                        const echoEnvelope = Math.exp(-2.5 * t);
                        const noise = (Math.random() * 2 - 1) * blastEnvelope * 0.9;
                        const thump = Math.sin(2 * Math.PI * 60 * t) * echoEnvelope * 0.4;
                        const metallic = Math.sin(2 * Math.PI * 900 * t) * blastEnvelope * 0.3;
                        sample = noise + thump + metallic;
                    } else if (type === 'cansado') {
                        const breathCycle = Math.sin(2 * Math.PI * 1.1 * t);
                        const slowEnvelope = Math.exp(-1.2 * (t % 0.7));
                        const rasp = (Math.random() * 2 - 1) * 0.08 * slowEnvelope;
                        sample = (breathCycle * 0.35 + rasp) * Math.min(1, (t + 0.1) * 2);
                    }
                    data[i] = sample;
                }
                return buffer;
            }
        };

        function createPlayerModel() {
            const group = new THREE.Group();

            const skinMaterial = new THREE.MeshStandardMaterial({
                color: 0xf0c8a0,
                roughness: 0.6,
                metalness: 0.1
            });

            const outfitMaterial = new THREE.MeshStandardMaterial({
                color: 0x223c7a,
                roughness: 0.8,
                metalness: 0.05
            });

            const accentMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b5a2b,
                roughness: 0.7,
                metalness: 0.2
            });

            // CabeÃ§a mais definida com formato melhor
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.26, 28, 22),
                skinMaterial
            );
            head.scale.set(1, 1.1, 1);
            head.position.y = 1.45;
            group.add(head);

            // Cabelo/capuz mais volumoso
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(0.28, 28, 22, 0, Math.PI * 2, 0, Math.PI / 2),
                accentMaterial
            );
            hair.position.y = 1.58;
            hair.scale.set(1.05, 1, 1.05);
            group.add(hair);
            
            // Detalhe de capuz (se for capuz)
            const hoodDetail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.27, 0.27, 0.15, 16),
                accentMaterial
            );
            hoodDetail.position.set(0, 1.35, -0.12);
            hoodDetail.rotation.x = Math.PI / 2;
            group.add(hoodDetail);

            // Torso mais volumoso e definido
            const torso = new THREE.Mesh(
                new THREE.CylinderGeometry(0.34, 0.4, 1.15, 28),
                outfitMaterial
            );
            torso.position.y = 0.75;
            group.add(torso);
            
            // Peito mais definido
            const chest = new THREE.Mesh(
                new THREE.SphereGeometry(0.36, 20, 16),
                outfitMaterial
            );
            chest.position.set(0, 1.15, 0.08);
            chest.scale.set(1, 0.7, 0.9);
            group.add(chest);

            // Cinto mais detalhado
            const belt = new THREE.Mesh(
                new THREE.TorusGeometry(0.32, 0.06, 14, 28),
                accentMaterial
            );
            belt.position.y = 0.3;
            belt.rotation.x = Math.PI / 2;
            group.add(belt);
            
            // Fivela do cinto
            const buckle = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 0.08, 0.02),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.7 })
            );
            buckle.position.set(0, 0.3, 0.32);
            group.add(buckle);

            function createLimb(width, height, depth, material) {
                const limb = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    material
                );
                limb.castShadow = true;
                return limb;
            }

            const leftArm = createLimb(0.15, 0.6, 0.15, outfitMaterial);
            leftArm.position.set(-0.38, 0.9, 0);
            group.add(leftArm);

            const rightArm = createLimb(0.15, 0.6, 0.15, outfitMaterial);
            rightArm.position.set(0.38, 0.9, 0);
            group.add(rightArm);

            const leftHand = createLimb(0.12, 0.2, 0.12, skinMaterial);
            leftHand.position.set(-0.38, 0.55, 0);
            group.add(leftHand);

            const rightHand = createLimb(0.12, 0.2, 0.12, skinMaterial);
            rightHand.position.set(0.38, 0.55, 0);
            group.add(rightHand);

            const leftLeg = createLimb(0.2, 0.7, 0.2, accentMaterial);
            leftLeg.position.set(-0.18, 0.05, 0);
            group.add(leftLeg);

            const rightLeg = createLimb(0.2, 0.7, 0.2, accentMaterial);
            rightLeg.position.set(0.18, 0.05, 0);
            group.add(rightLeg);

            // PÃ©s mais definidos (botas)
            const bootMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.85,
                metalness: 0.1
            });
            
            const leftFoot = createLimb(0.22, 0.12, 0.32, bootMaterial);
            leftFoot.position.set(-0.18, -0.3, 0.08);
            group.add(leftFoot);
            
            // Sola da bota
            const leftSole = new THREE.Mesh(
                new THREE.BoxGeometry(0.24, 0.04, 0.34),
                new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 })
            );
            leftSole.position.set(-0.18, -0.36, 0.08);
            group.add(leftSole);

            const rightFoot = createLimb(0.22, 0.12, 0.32, bootMaterial);
            rightFoot.position.set(0.18, -0.3, 0.08);
            group.add(rightFoot);
            
            // Sola da bota
            const rightSole = new THREE.Mesh(
                new THREE.BoxGeometry(0.24, 0.04, 0.34),
                new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 })
            );
            rightSole.position.set(0.18, -0.36, 0.08);
            group.add(rightSole);

            const leftEye = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 12, 12),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            leftEye.position.set(-0.08, 1.48, 0.24);
            group.add(leftEye);

            const rightEye = leftEye.clone();
            rightEye.position.x = 0.08;
            group.add(rightEye);

            const leftPupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            leftPupil.position.set(-0.08, 1.48, 0.28);
            group.add(leftPupil);

            const rightPupil = leftPupil.clone();
            rightPupil.position.x = 0.08;
            group.add(rightPupil);

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            const animationState = {
                elapsed: 0,
                state: 'idle',
                lerp: 1,
                config: {
                    speed: 2,
                    armAmp: 0.05,
                    legAmp: 0.05,
                    bob: 0.02,
                    sway: 0.05
                }
            };

            const STATE_PRESETS = {
                idle: { speed: 1.5, armAmp: 0.12, legAmp: 0.08, bob: 0.03, sway: 0.04, headBob: 0.02 },
                alerta: { speed: 2.2, armAmp: 0.1, legAmp: 0.06, bob: 0.02, sway: 0.08, headBob: 0.03 },
                walk: { speed: 3.8, armAmp: 0.25, legAmp: 0.28, bob: 0.06, sway: 0.1, headBob: 0.04 },
                run: { speed: 7, armAmp: 0.45, legAmp: 0.55, bob: 0.12, sway: 0.15, headBob: 0.06 },
                tired: { speed: 1.2, armAmp: 0.15, legAmp: 0.1, bob: 0.04, sway: 0.05, headBob: 0.03 },
                fear: { speed: 2.8, armAmp: 0.2, legAmp: 0.15, bob: 0.05, sway: 0.12, headBob: 0.05 },
                victory: { speed: 2.0, armAmp: 0.3, legAmp: 0.1, bob: 0.08, sway: 0.06, headBob: 0.04 }
            };

            function setAnimationState(newState) {
                if (!STATE_PRESETS[newState]) newState = 'idle';
                animationState.state = newState;
                animationState.target = STATE_PRESETS[newState];
            }

            group.userData.setState = setAnimationState;
            setAnimationState('idle');

            group.userData.animate = (delta) => {
                animationState.elapsed += delta;
                if (animationState.target) {
                    const t = 1 - Math.pow(0.001, delta);
                    animationState.config.speed += (animationState.target.speed - animationState.config.speed) * t;
                    animationState.config.armAmp += (animationState.target.armAmp - animationState.config.armAmp) * t;
                    animationState.config.legAmp += (animationState.target.legAmp - animationState.config.legAmp) * t;
                    animationState.config.bob += (animationState.target.bob - animationState.config.bob) * t;
                    animationState.config.sway += (animationState.target.sway - animationState.config.sway) * t;
                    animationState.config.headBob = animationState.config.headBob || 0;
                    animationState.config.headBob += ((animationState.target.headBob || 0) - animationState.config.headBob) * t;
                }

                const cycle = animationState.elapsed * animationState.config.speed;
                const bob = Math.sin(cycle) * animationState.config.bob;
                group.position.y = 0.05 + bob;

                // Movimento mais natural e fluido
                const sway = Math.sin(cycle * 0.5) * animationState.config.sway;
                torso.rotation.y = sway * 0.3;
                
                // CabeÃ§a com movimento mais expressivo (respiraÃ§Ã£o e balanÃ§o)
                const headBob = Math.sin(cycle * 0.8) * (animationState.config.headBob || 0.02);
                head.rotation.y = sway * 0.6 + headBob * 0.3;
                head.rotation.x = Math.sin(cycle * 0.4) * 0.05;

                // BraÃ§os com movimento mais amplo e sincronizado
                const armPhase = cycle;
                leftArm.rotation.x = Math.sin(armPhase) * animationState.config.armAmp;
                rightArm.rotation.x = Math.sin(armPhase + Math.PI) * animationState.config.armAmp;
                leftArm.rotation.z = Math.sin(armPhase * 0.5) * animationState.config.armAmp * 0.3;
                rightArm.rotation.z = Math.sin(armPhase * 0.5 + Math.PI) * animationState.config.armAmp * 0.3;

                // Pernas com movimento mais natural
                const legPhase = cycle;
                leftLeg.rotation.x = Math.sin(legPhase + Math.PI) * animationState.config.legAmp;
                rightLeg.rotation.x = Math.sin(legPhase) * animationState.config.legAmp;
                
                // MÃ£os com leve movimento
                leftHand.rotation.x = Math.sin(armPhase * 1.2) * 0.1;
                rightHand.rotation.x = Math.sin(armPhase * 1.2 + Math.PI) * 0.1;
            };

            return group;
        }

        function clearScene() {
            if (!gameState.scene) return;
            while (gameState.scene.children.length > 0) {
                const child = gameState.scene.children[0];
                gameState.scene.remove(child);
            }
            gameState.scene.userData = {};
        }

        function ensurePlayer() {
            if (!gameState.scene) return null;
            if (!gameState.player) {
                gameState.player = createPlayerModel();
            }
            if (!gameState.scene.children.includes(gameState.player)) {
                gameState.scene.add(gameState.player);
            }
            return gameState.player;
        }

        function positionPlayer(x, y, z, rotationY = 0) {
            const player = ensurePlayer();
            if (!player) return;
            const baseOffset = 0.4;
            player.position.set(x, baseOffset + y, z);
            player.rotation.y = rotationY;
            player.visible = false;
        }

        function setPlayerState(state) {
            const player = ensurePlayer();
            gameState.playerState = state;
            if (player?.userData?.setState) {
                player.userData.setState(state);
            }
        }

        function setAmbient(type) {
            if (gameState.ambientAtual === type) return;
            gameState.ambientAtual = type;
            if (!type) {
                audioManager.stopAmbient();
            } else {
                audioManager.playAmbient(type);
            }
        }

        function addCommonLights(scene, options = {}) {
            const { intensity = 1, warm = false } = options;
            
            // IluminaÃ§Ã£o ambiente melhorada - mais sutil e cinematogrÃ¡fica
            const ambient = new THREE.AmbientLight(warm ? 0xffe0b2 : 0x8fb4ff, 0.45 * intensity);
            scene.add(ambient);

            // Luz hemisfÃ©rica com mais contraste e atmosfera
            const hemi = new THREE.HemisphereLight(
                warm ? 0xfff5e6 : 0xe8f0ff, 
                warm ? 0x2d1508 : 0x030812, 
                0.7 * intensity
            );
            scene.add(hemi);

            // Luz principal direcional - iluminaÃ§Ã£o cinematogrÃ¡fica com sombras suaves
            const keyLight = new THREE.DirectionalLight(warm ? 0xffd9a5 : 0xf0f8ff, 1.4 * intensity);
            keyLight.position.set(8, 15, 8);
            keyLight.castShadow = true;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 200;
            keyLight.shadow.camera.left = -50;
            keyLight.shadow.camera.right = 50;
            keyLight.shadow.camera.top = 50;
            keyLight.shadow.camera.bottom = -50;
            keyLight.shadow.mapSize.set(4096, 4096);
            keyLight.shadow.bias = -0.0001;
            keyLight.shadow.normalBias = 0.02;
            keyLight.shadow.radius = 6;
            keyLight.shadow.blurSamples = 25;
            scene.add(keyLight);

            // Luz de preenchimento melhorada - mais suave
            const fillLight = new THREE.PointLight(0x88aaff, 0.4 * intensity, 35, 1.8);
            fillLight.position.set(-5, 10, -5);
            fillLight.castShadow = true;
            fillLight.shadow.mapSize.set(2048, 2048);
            scene.add(fillLight);

            // Luz adicional para mais profundidade
            const rimLight = new THREE.DirectionalLight(warm ? 0xffaa44 : 0x4a6fa5, 0.4 * intensity);
            rimLight.position.set(-8, 5, -8);
            scene.add(rimLight);
        }

        function createGround(width, depth, color) {
            // Geometria mais detalhada com mais segmentos para melhor qualidade
            const segments = Math.max(48, Math.floor(width / 1.5));
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(width, depth, segments, segments),
                new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness: 0.92,
                    metalness: 0.03,
                    flatShading: false
                })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            
            // VariaÃ§Ã£o de altura mais realista e orgÃ¢nica (simulaÃ§Ã£o de terreno natural)
            const vertices = ground.geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                
                // MÃºltiplas camadas de ruÃ­do para terreno mais natural
                const noise1 = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 0.08;
                const noise2 = Math.sin(x * 0.8) * Math.cos(z * 0.8) * 0.04;
                const noise3 = Math.sin(x * 1.5) * Math.cos(z * 1.5) * 0.02;
                const height = noise1 + noise2 + noise3;
                vertices.setY(i, y + height);
                
                // VariaÃ§Ã£o sutil de cor baseada na altura (simula normal map fake)
                const colorVariation = 1.0 + height * 0.3;
                colors.push(colorVariation, colorVariation, colorVariation);
            }
            vertices.needsUpdate = true;
            ground.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            ground.geometry.computeVertexNormals();
            
            // Ativar vertex colors no material para variaÃ§Ã£o de cor
            ground.material.vertexColors = true;
            
            return ground;
        }

        // Sistema de partÃ­culas (vaga-lumes) para atmosfera mÃ­stica
        function createFireflies(scene, count = 30) {
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                // PosiÃ§Ãµes aleatÃ³rias na floresta
                positions[i3] = (Math.random() - 0.5) * 60;
                positions[i3 + 1] = Math.random() * 8 + 1;
                positions[i3 + 2] = (Math.random() - 0.5) * 60;
                
                // Cores douradas/amarelas para vaga-lumes
                const intensity = 0.6 + Math.random() * 0.4;
                colors[i3] = 1.0 * intensity;
                colors[i3 + 1] = 0.85 * intensity;
                colors[i3 + 2] = 0.3 * intensity;
                
                // Tamanhos variados
                sizes[i] = 0.5 + Math.random() * 0.5;
                
                // Velocidades aleatÃ³rias para movimento orgÃ¢nico
                velocities[i3] = (Math.random() - 0.5) * 0.02;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.015;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.15,
                map: createFireflyTexture(),
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true,
                sizeAttenuation: true
            });
            
            const fireflies = new THREE.Points(particles, material);
            fireflies.userData.velocities = velocities;
            fireflies.userData.time = 0;
            scene.add(fireflies);
            
            return fireflies;
        }
        
        // Textura simples para vaga-lumes (ponto brilhante)
        function createFireflyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 220, 100, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Atualizar partÃ­culas (chamar no loop de animaÃ§Ã£o)
        function updateFireflies(fireflies, delta) {
            if (!fireflies || !fireflies.userData) return;
            
            const positions = fireflies.geometry.attributes.position;
            const velocities = fireflies.userData.velocities;
            fireflies.userData.time += delta;
            
            for (let i = 0; i < positions.count; i++) {
                const i3 = i * 3;
                
                // Movimento orgÃ¢nico com seno/cosseno
                positions.array[i3] += velocities[i3] + Math.sin(fireflies.userData.time + i) * 0.001;
                positions.array[i3 + 1] += velocities[i3 + 1] + Math.cos(fireflies.userData.time * 0.7 + i) * 0.001;
                positions.array[i3 + 2] += velocities[i3 + 2] + Math.sin(fireflies.userData.time * 0.5 + i) * 0.001;
                
                // Limites da Ã¡rea (wrap around)
                if (Math.abs(positions.array[i3]) > 30) velocities[i3] *= -1;
                if (positions.array[i3 + 1] < 0.5 || positions.array[i3 + 1] > 10) velocities[i3 + 1] *= -1;
                if (Math.abs(positions.array[i3 + 2]) > 30) velocities[i3 + 2] *= -1;
            }
            
            positions.needsUpdate = true;
        }

        function criarModeloLobo() {
            const group = new THREE.Group();

            // Materiais mais realistas de lobo
            const furMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a3a, 
                roughness: 0.87,
                metalness: 0.02
            });
            const darkFur = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                roughness: 0.85,
                metalness: 0.01
            });
            const muzzleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.8,
                metalness: 0.01
            });
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0xff6666,
                emissive: 0xff4444,
                emissiveIntensity: 1.2,
                roughness: 0.3,
                metalness: 0.1
            });
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                roughness: 0.89,
                metalness: 0.01
            });
            const pawMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.82,
                metalness: 0.02
            });

            // Corpo humanoide/bÃ­pede de lobo - mais esguio e Ã¡gil
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.58, 1.6, 20), furMaterial);
            torso.position.y = 1.25;
            group.add(torso);

            const chest = new THREE.Mesh(new THREE.CylinderGeometry(0.48, 0.52, 0.85, 20), darkFur);
            chest.position.set(0, 1.55, 0.12);
            group.add(chest);

            // Cintura/pelve
            const pelvis = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.42, 0.38, 18), furMaterial);
            pelvis.position.y = 0.65;
            group.add(pelvis);

            // CabeÃ§a de lobo mais realista - mais alongada
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 20, 18), furMaterial);
            head.scale.set(1.1, 1.0, 1.2);
            head.position.set(0, 2.15, 0.18);
            group.add(head);

            // Focinho de lobo mais longo e realista
            const muzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.22, 0.6, 16), muzzleMaterial);
            muzzle.rotation.x = Math.PI / 2;
            muzzle.position.set(0, 2.05, 0.65);
            group.add(muzzle);

            // Nariz preto
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 10),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5 }));
            nose.position.set(0, 2.0, 0.85);
            group.add(nose);

            // Orelhas de lobo mais pontiagudas e realistas
            for (const side of [-1, 1]) {
                const ear = new THREE.Mesh(new THREE.ConeGeometry(0.16, 0.45, 10), darkFur);
                ear.position.set(0.25 * side, 2.3, 0.08);
                ear.rotation.set(Math.PI / 2.2, 0, -side * 0.4);
                group.add(ear);
            }

            // Olhos brilhantes de lobo - mais expressivos
            for (const side of [-1, 1]) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.11, 16, 16), glowMaterial);
                eye.position.set(0.18 * side, 2.1, 0.38);
                group.add(eye);
            }

            // Cauda de lobo mais peluda
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.85, 12), furMaterial);
            tail.position.set(0, 0.85, -0.5);
            tail.rotation.x = -Math.PI / 2.8;
            group.add(tail);

            // BraÃ§os humanos de lobo
            for (const side of [-1, 1]) {
                // Ombro
                const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), furMaterial);
                shoulder.position.set(0.42 * side, 1.8, 0);
                group.add(shoulder);

                // BraÃ§o superior
                const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 0.85, 14), armMaterial);
                upperArm.position.set(0.48 * side, 1.35, 0);
                upperArm.rotation.z = side * Math.PI / 10;
                group.add(upperArm);

                // Cotovelo
                const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 10), armMaterial);
                elbow.position.set(0.55 * side, 0.95, 0.05);
                group.add(elbow);

                // AntebraÃ§o
                const foreArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.9, 14), armMaterial);
                foreArm.position.set(0.6 * side, 0.45, 0.1);
                foreArm.rotation.z = side * Math.PI / 15;
                group.add(foreArm);

                // Pata/mÃ£o de lobo
                const paw = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.18, 0.22, 8), pawMaterial);
                paw.position.set(0.65 * side, 0.0, 0.12);
                paw.rotation.z = side * Math.PI / 20;
                group.add(paw);
            }

            // Pernas bÃ­pedes (2 pernas em vez de 4)
            for (const side of [-1, 1]) {
                // Quadril
                const hip = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), furMaterial);
                hip.position.set(0.22 * side, 0.6, 0);
                group.add(hip);

                // Coxa
                const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.19, 0.8, 16), armMaterial);
                thigh.position.set(0.25 * side, 0.2, 0);
                thigh.rotation.x = 0.1;
                group.add(thigh);

                // Joelho
                const knee = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), armMaterial);
                knee.position.set(0.28 * side, -0.2, 0);
                group.add(knee);

                // Canela
                const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.16, 0.75, 16), armMaterial);
                shin.position.set(0.3 * side, -0.6, 0);
                shin.rotation.x = -0.05;
                group.add(shin);

                // Pata/casco de lobo
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.12, 0.3, 8), pawMaterial);
                foot.position.set(0.32 * side, -1.0, 0.08);
                foot.rotation.x = Math.PI / 12;
                group.add(foot);
            }

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function criarModeloBode() {
            const group = new THREE.Group();

            // Materiais mais realistas com variaÃ§Ã£o de textura
            const furMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a241f, 
                roughness: 0.92,
                metalness: 0.01
            });
            const accentFur = new THREE.MeshStandardMaterial({ 
                color: 0x1a1612, 
                roughness: 0.95,
                metalness: 0.01
            });
            const darkFur = new THREE.MeshStandardMaterial({ 
                color: 0x15110d, 
                roughness: 0.9,
                metalness: 0.02
            });
            const hornMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xc4b088, 
                roughness: 0.55, 
                metalness: 0.35,
                bumpScale: 0.3
            });
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffeb80,
                emissive: 0xfff4a8,
                emissiveIntensity: 1.2,
                roughness: 0.25,
                metalness: 0.2
            });
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1f1a16, 
                roughness: 0.92,
                metalness: 0.02
            });
            const hoofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f0a08, 
                roughness: 0.6,
                metalness: 0.08
            });
            const noseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a1f1f, 
                roughness: 0.5,
                metalness: 0.1
            });

            // Corpo humanoide/bÃ­pede com proporÃ§Ãµes mais realistas
            // Torso principal com forma mais natural
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.52, 0.68, 1.85, 24), furMaterial);
            torso.position.y = 1.52;
            torso.scale.z = 0.85; // Profundidade reduzida para parecer mais natural
            group.add(torso);

            // Peito com definiÃ§Ã£o muscular
            const chest = new THREE.Mesh(new THREE.CylinderGeometry(0.52, 0.56, 0.92, 20), accentFur);
            chest.position.set(0, 1.87, 0.12);
            chest.scale.z = 0.9;
            group.add(chest);

            // MÃºsculos do peito
            for (const side of [-1, 1]) {
                const pec = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), darkFur);
                pec.position.set(0.22 * side, 1.9, 0.18);
                pec.scale.set(1, 0.8, 0.6);
                group.add(pec);
            }

            // Cintura/pelve mais definida
            const pelvis = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.52, 0.42, 20), furMaterial);
            pelvis.position.y = 0.71;
            pelvis.scale.z = 0.88;
            group.add(pelvis);

            // CabeÃ§a de bode mais realista com formato alongado
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.42, 24, 20), furMaterial);
            head.position.set(0, 2.62, 0.26);
            head.rotation.x = -0.15; // InclinaÃ§Ã£o sutil
            head.scale.set(1.05, 0.9, 0.83); // Formato alongado
            group.add(head);

            // Testa mais pronunciada
            const forehead = new THREE.Mesh(new THREE.SphereGeometry(0.24, 16, 14), furMaterial);
            forehead.position.set(0, 2.75, 0.05);
            forehead.scale.set(1.2, 0.7, 0.9);
            group.add(forehead);

            // Focinho mais detalhado e realista de bode - formato mais triangular
            const snoutBase = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.26, 0.65, 20), accentFur);
            snoutBase.rotation.x = Math.PI / 2;
            snoutBase.position.set(0, 2.47, 0.72);
            snoutBase.scale.z = 0.85;
            group.add(snoutBase);

            // Ponta do focinho
            const snoutTip = new THREE.Mesh(new THREE.ConeGeometry(0.14, 0.25, 16), noseMaterial);
            snoutTip.rotation.x = Math.PI / 2;
            snoutTip.position.set(0, 2.45, 0.95);
            group.add(snoutTip);

            // DivisÃ£o do lÃ¡bio superior
            const upperLip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.04, 0.08, 4), noseMaterial);
            upperLip.position.set(0, 2.4, 0.98);
            group.add(upperLip);

            // Narinas de bode mais realistas - formato ovalado
            for (const side of [-1, 1]) {
                const nostril = new THREE.Mesh(new THREE.SphereGeometry(0.045, 12, 10), 
                    new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.3, metalness: 0.1 }));
                nostril.position.set(side * 0.065, 2.46, 0.91);
                nostril.scale.set(0.9, 0.7, 1.2);
                group.add(nostril);
            }

            // Barba mais realista e volumosa com textura
            const beard = new THREE.Mesh(new THREE.ConeGeometry(0.24, 0.9, 18), darkFur);
            beard.position.set(0, 2.22, 0.54);
            group.add(beard);

            // Detalhes na barba - mechas individuais
            for (let i = 0; i < 3; i++) {
                const beardStrand = new THREE.Mesh(new THREE.ConeGeometry(0.06 + Math.random() * 0.04, 0.5 + Math.random() * 0.3, 10), 
                    i === 1 ? accentFur : darkFur);
                beardStrand.position.set(
                    (Math.random() - 0.5) * 0.15,
                    2.1 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.1
                );
                beardStrand.rotation.z = (Math.random() - 0.5) * 0.3;
                group.add(beardStrand);
            }

            // Orelhas de bode mais realistas - pontiagudas e mÃ³veis
            for (const side of [-1, 1]) {
                // Orelha externa
                const ear = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.45, 14), furMaterial);
                ear.position.set(0.3 * side, 2.67, 0.08);
                ear.rotation.set(Math.PI / 2.15, side * 0.2, -side * 0.45);
                group.add(ear);
                
                // Parte interna da orelha (mais clara)
                const earInner = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 12),
                    new THREE.MeshStandardMaterial({ color: 0x3a2f25, roughness: 0.8 }));
                earInner.position.set(0.31 * side, 2.66, 0.1);
                earInner.rotation.set(Math.PI / 2.15, side * 0.2, -side * 0.45);
                group.add(earInner);
            }

            // Chifres mais realistas - curva natural de bode
            for (const side of [-1, 1]) {
                // Base do chifre
                const hornBase = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.14, 0.3, 16), hornMaterial);
                hornBase.position.set(0.38 * side, 2.88, -0.08);
                hornBase.rotation.z = side * Math.PI / 6;
                hornBase.rotation.x = Math.PI / 3;
                group.add(hornBase);

                // Chifre curvo - usando torus para curva natural
                const horn = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.095, 24, 48, Math.PI * 1.45), hornMaterial);
                horn.position.set(0.4 * side, 2.92, -0.12);
                horn.rotation.set(Math.PI / 2.05, side > 0 ? Math.PI / 1.75 : -Math.PI / 1.75, 0);
                group.add(horn);

                // Ponta do chifre
                const hornTip = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 12), hornMaterial);
                hornTip.position.set(side > 0 ? 0.35 : -0.35, 2.78, -0.5);
                hornTip.rotation.z = side * Math.PI / 5;
                hornTip.rotation.x = Math.PI / 2.5;
                group.add(hornTip);

                // AnÃ©is no chifre (caracterÃ­stica de bodes)
                for (let i = 0; i < 3; i++) {
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.08 + i * 0.02, 0.01, 8, 16), 
                        new THREE.MeshStandardMaterial({ color: 0x8a7a5a, roughness: 0.4, metalness: 0.5 }));
                    ring.position.set(
                        side > 0 ? 0.38 + i * 0.1 : -0.38 - i * 0.1,
                        2.85 - i * 0.08,
                        -0.2 - i * 0.15
                    );
                    ring.rotation.z = side * Math.PI / 5;
                    ring.rotation.x = Math.PI / 2.3;
                    group.add(ring);
                }
            }

            // Olhos mais realistas - formato de elipse horizontal
            for (const side of [-1, 1]) {
                // Olho principal
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.125, 20, 16), eyeMaterial);
                eye.position.set(0.19 * side, 2.61, 0.52);
                eye.scale.set(1.2, 1, 1);
                group.add(eye);

                // Ãris mais escura
                const iris = new THREE.Mesh(new THREE.SphereGeometry(0.09, 16, 14),
                    new THREE.MeshStandardMaterial({ color: 0xcc9900, roughness: 0.4 }));
                iris.position.set(0.19 * side, 2.61, 0.55);
                group.add(iris);

                // Pupila
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 12),
                    new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 }));
                pupil.position.set(0.19 * side, 2.61, 0.56);
                group.add(pupil);

                // PÃ¡lpebra superior
                const eyelid = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.02, 8, 16, Math.PI),
                    new THREE.MeshStandardMaterial({ color: 0x1e1a18, roughness: 0.9 }));
                eyelid.position.set(0.19 * side, 2.64, 0.51);
                eyelid.rotation.x = Math.PI / 2;
                group.add(eyelid);
            }

            // BraÃ§os humanos menores e mais proporcionados
            for (const side of [-1, 1]) {
                // Ombro menor
                const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.14, 14, 12), furMaterial);
                shoulder.position.set(0.48 * side, 2.0, 0);
                shoulder.scale.set(1, 1.05, 0.95);
                group.add(shoulder);

                // BraÃ§o superior menor
                const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.14, 0.75, 16), armMaterial);
                upperArm.position.set(0.52 * side, 1.55, 0);
                upperArm.rotation.z = side * Math.PI / 10;
                group.add(upperArm);

                // BÃ­ceps menor
                const bicep = new THREE.Mesh(new THREE.SphereGeometry(0.095, 10, 10), accentFur);
                bicep.position.set(0.53 * side, 1.45, 0.06);
                bicep.scale.set(1, 1.2, 0.75);
                group.add(bicep);

                // Cotovelo menor
                const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.095, 10, 10), armMaterial);
                elbow.position.set(0.6 * side, 1.12, 0.05);
                group.add(elbow);

                // AntebraÃ§o menor
                const foreArm = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.11, 0.78, 16), armMaterial);
                foreArm.position.set(0.64 * side, 0.58, 0.09);
                foreArm.rotation.z = side * Math.PI / 15;
                group.add(foreArm);

                // Pulso menor
                const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.075, 8, 8), armMaterial);
                wrist.position.set(0.67 * side, 0.08, 0.12);
                group.add(wrist);

                // MÃ£o menor - formato de pata com dedos
                const hand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.17, 0.22, 8), armMaterial);
                hand.position.set(0.69 * side, 0.0, 0.15);
                hand.rotation.z = side * Math.PI / 22;
                group.add(hand);

                // Dedo polegar menor
                const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.09, 6), armMaterial);
                thumb.position.set(0.73 * side, 0.02, 0.18);
                thumb.rotation.z = side * Math.PI / 6;
                thumb.rotation.x = Math.PI / 3;
                group.add(thumb);
            }

            // Pernas bÃ­pedes mais realistas com musculatura definida
            for (const side of [-1, 1]) {
                // Quadril mais robusto
                const hip = new THREE.Mesh(new THREE.SphereGeometry(0.17, 16, 14), furMaterial);
                hip.position.set(0.26 * side, 0.71, 0);
                hip.scale.set(1, 1.1, 0.9);
                group.add(hip);

                // Coxa mais musculosa
                const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.19, 0.23, 0.92, 20), armMaterial);
                thigh.position.set(0.29 * side, 0.21, 0);
                thigh.rotation.x = 0.1;
                group.add(thigh);

                // MÃºsculo quadrÃ­ceps
                const quad = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), accentFur);
                quad.position.set(0.3 * side, 0.35, 0.08);
                quad.scale.set(1, 1.4, 0.7);
                group.add(quad);

                // Joelho mais pronunciado
                const knee = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), armMaterial);
                knee.position.set(0.31 * side, -0.24, 0);
                knee.scale.set(1, 0.9, 0.85);
                group.add(knee);

                // Canela mais definida
                const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.19, 0.87, 20), armMaterial);
                shin.position.set(0.33 * side, -0.69, 0);
                shin.rotation.x = -0.05;
                group.add(shin);

                // Tornozelo
                const ankle = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 10), armMaterial);
                ankle.position.set(0.34 * side, -1.08, 0.05);
                group.add(ankle);

                // PÃ©/casco de bode mais realista - formato de casco partido
                // Parte traseira do casco
                const hoofBack = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.16, 0.2, 8), hoofMaterial);
                hoofBack.position.set(0.36 * side, -1.18, 0.08);
                hoofBack.rotation.x = Math.PI / 14;
                group.add(hoofBack);

                // Parte dianteira do casco
                const hoofFront = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.14, 0.18, 8), hoofMaterial);
                hoofFront.position.set(0.36 * side, -1.16, 0.28);
                hoofFront.rotation.x = Math.PI / 10;
                group.add(hoofFront);

                // DivisÃ£o do casco (caracterÃ­stica de bodes)
                const hoofSplit = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.12, 0.25, 4), 
                    new THREE.MeshStandardMaterial({ color: 0x0a0806, roughness: 0.5 }));
                hoofSplit.position.set(0.36 * side, -1.17, 0.18);
                hoofSplit.rotation.x = Math.PI / 12;
                group.add(hoofSplit);
            }

            // Cauda de bode realista
            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.35, 12), darkFur);
            tail.position.set(0, 0.95, -0.45);
            tail.rotation.x = Math.PI / 4;
            tail.rotation.z = -0.1;
            group.add(tail);

            // Ponta da cauda (pincel)
            const tailTip = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 10), accentFur);
            tailTip.position.set(0, 1.08, -0.62);
            tailTip.rotation.x = Math.PI / 3;
            tailTip.rotation.z = -0.15;
            group.add(tailTip);

            // Detalhes de pelagem - variaÃ§Ãµes sutis na textura
            // Pelos no peito
            for (let i = 0; i < 5; i++) {
                const chestFur = new THREE.Mesh(new THREE.ConeGeometry(0.03 + Math.random() * 0.02, 0.15 + Math.random() * 0.1, 8),
                    Math.random() > 0.5 ? darkFur : accentFur);
                chestFur.position.set(
                    (Math.random() - 0.5) * 0.35,
                    1.95 + Math.random() * 0.15,
                    0.2 + Math.random() * 0.1
                );
                chestFur.rotation.z = (Math.random() - 0.5) * 0.5;
                chestFur.rotation.x = Math.random() * 0.3;
                group.add(chestFur);
            }

            // Pelos no pescoÃ§o
            for (let i = 0; i < 6; i++) {
                const neckFur = new THREE.Mesh(new THREE.ConeGeometry(0.04 + Math.random() * 0.02, 0.2 + Math.random() * 0.15, 8),
                    Math.random() > 0.5 ? furMaterial : darkFur);
                neckFur.position.set(
                    (Math.random() - 0.5) * 0.3,
                    2.2 + Math.random() * 0.25,
                    0.05 + Math.random() * 0.15
                );
                neckFur.rotation.z = (Math.random() - 0.5) * 0.6;
                neckFur.rotation.y = (Math.random() - 0.5) * 0.4;
                group.add(neckFur);
            }

            // Aura sutil mais realista
            const aura = new THREE.Mesh(
                new THREE.SphereGeometry(1.35, 28, 20),
                new THREE.MeshStandardMaterial({
                    color: 0x251d18,
                    transparent: true,
                    opacity: 0.12,
                    emissive: 0x2d2219,
                    emissiveIntensity: 0.2,
                    roughness: 0.9
                })
            );
            aura.position.y = 1.52;
            aura.scale.set(1, 1.1, 0.95);
            group.add(aura);

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function animateModelMove(model, from, to, duration = 2.5) {
            return new Promise((resolve) => {
                if (!model || !from || !to) {
                    console.warn('animateModelMove: parÃ¢metros invÃ¡lidos', { model, from, to });
                    resolve();
                    return;
                }
                
                const start = performance.now();
                const origin = from.clone();
                const target = to.clone();
                let animationFrameId = null;
                let timeoutId = null;
                
                const updateRotation = () => {
                    try {
                        if (model && model.position) {
                            const direction = new THREE.Vector3();
                            direction.subVectors(target, model.position);
                            if (direction.length() > 0.01) {
                    model.lookAt(target.x, model.position.y, target.z);
                            }
                        }
                    } catch (e) {
                        console.warn('Erro ao atualizar rotaÃ§Ã£o:', e);
                    }
                };
                
                updateRotation();
                
                function step(now) {
                    try {
                        if (!model || !model.position) {
                            if (animationFrameId) cancelAnimationFrame(animationFrameId);
                            if (timeoutId) clearTimeout(timeoutId);
                            resolve();
                            return;
                        }
                        
                    const elapsed = (now - start) / (duration * 1000);
                    const t = Math.min(Math.max(elapsed, 0), 1);
                    model.position.lerpVectors(origin, target, t);
                    updateRotation();
                        
                    if (t < 1) {
                            animationFrameId = requestAnimationFrame(step);
                    } else {
                            model.position.copy(target);
                            if (timeoutId) clearTimeout(timeoutId);
                        resolve();
                    }
                    } catch (error) {
                        console.error('Erro na animaÃ§Ã£o:', error);
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        if (timeoutId) clearTimeout(timeoutId);
                        if (model && model.position) {
                            model.position.copy(target);
                        }
                        resolve();
                    }
                }
                
                animationFrameId = requestAnimationFrame(step);
                
                // Timeout de seguranÃ§a para evitar travamentos
                timeoutId = setTimeout(() => {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    if (model && model.position) {
                        model.position.copy(target);
                    }
                    resolve();
                }, (duration + 2) * 1000);
            });
        }

        function animateDoor(pivot, from, to, duration = 1.6) {
            if (!pivot) return Promise.resolve();
            return new Promise((resolve) => {
                const start = performance.now();
                function step(now) {
                    const elapsed = (now - start) / (duration * 1000);
                    const t = Math.min(Math.max(elapsed, 0), 1);
                    const eased = THREE.MathUtils.smoothstep(t, 0, 1);
                    pivot.rotation.y = THREE.MathUtils.lerp(from, to, eased);
                    if (t < 1) {
                        requestAnimationFrame(step);
                    } else {
                        resolve();
                    }
                }
                requestAnimationFrame(step);
            });
        }

        function resetUpdateLoop() {
            gameState.activeUpdate = null;
        }

        function criarModeloGanso() {
            const group = new THREE.Group();
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xf4f4f4, roughness: 0.6 });
            const neckMaterial = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.55 });
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xffb347, roughness: 0.35 });
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0xff9f3a, roughness: 0.4 });

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.55, 18, 16), bodyMaterial);
            body.scale.set(1.2, 0.8, 1.2);
            body.position.y = 0.7;
            group.add(body);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.17, 0.2, 0.9, 12), neckMaterial);
            neck.position.set(0, 1.3, 0.25);
            group.add(neck);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 14), neckMaterial);
            head.position.set(0, 1.75, 0.45);
            group.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.16, 0.35, 10), beakMaterial);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 1.7, 0.75);
            group.add(beak);

            for (const side of [-1, 1]) {
                const wing = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.8, 12), bodyMaterial);
                wing.position.set(0.55 * side, 0.8, 0);
                wing.rotation.set(0, 0, -side * Math.PI / 2.6);
                group.add(wing);
            }

            for (const side of [-1, 1]) {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.09, 0.8, 10), legMaterial);
                leg.position.set(0.18 * side, 0.2, 0.1);
                group.add(leg);
            }

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function criarModeloGansoFeminino() {
            const group = criarModeloGanso();
            // Adicionar detalhes femininos (pode ser um laÃ§o ou cor diferente)
            const bow = new THREE.Mesh(
                new THREE.TorusGeometry(0.12, 0.04, 8, 16),
                new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.5 })
            );
            bow.position.set(0, 1.4, 0.3);
            bow.rotation.x = Math.PI / 2;
            group.add(bow);
            return group;
        }

        function criarModeloLeao() {
            const group = new THREE.Group();
            // Materiais mais vibrantes, majestosos e realistas
            const furMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd5a8, 
                roughness: 0.85,
                metalness: 0.02
            });
            const darkFurMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe8b87d, 
                roughness: 0.87,
                metalness: 0.02
            });
            const maneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b6a3a, 
                roughness: 0.88,
                metalness: 0.0,
                emissive: 0x6a4a2a,
                emissiveIntensity: 0.12
            });
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffe600,
                emissive: 0xffd700,
                emissiveIntensity: 1.5,
                roughness: 0.1,
                metalness: 0.3
            });
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0cc96, 
                roughness: 0.85,
                metalness: 0.02
            });
            const pawMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x9a7a5a, 
                roughness: 0.7,
                metalness: 0.08
            });
            const noseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5a3525, 
                roughness: 0.5,
                metalness: 0.15
            });

            // Corpo humanoide/bÃ­pede de leÃ£o - proporÃ§Ãµes mais majestosas e imponentes
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.58, 0.75, 2.0, 32), furMaterial);
            torso.position.y = 1.48;
            torso.scale.z = 0.9;
            group.add(torso);

            // Peito musculoso e muito mais imponente
            const chest = new THREE.Mesh(new THREE.CylinderGeometry(0.62, 0.7, 1.25, 30), darkFurMaterial);
            chest.position.set(0, 1.78, 0.28);
            chest.scale.z = 0.95;
            group.add(chest);
            
            // Detalhes de pelagem no peito (simulaÃ§Ã£o de pelo)
            for (let i = 0; i < 8; i++) {
                const chestFur = new THREE.Mesh(
                    new THREE.ConeGeometry(0.03 + Math.random() * 0.02, 0.12 + Math.random() * 0.08, 8),
                    Math.random() > 0.5 ? darkFurMaterial : furMaterial
                );
                chestFur.position.set(
                    (Math.random() - 0.5) * 0.5,
                    1.6 + Math.random() * 0.3,
                    0.35 + Math.random() * 0.15
                );
                chestFur.rotation.z = (Math.random() - 0.5) * 0.4;
                chestFur.rotation.x = Math.random() * 0.3;
                group.add(chestFur);
            }
            
            // MÃºsculos do peito muito mais definidos
            for (const side of [-1, 1]) {
                const pec = new THREE.Mesh(new THREE.SphereGeometry(0.14, 18, 16), darkFurMaterial);
                pec.scale.set(1.1, 0.75, 1.3);
                pec.position.set(0.28 * side, 1.73, 0.38);
                group.add(pec);
                
                // Detalhe do mÃºsculo peitoral
                const pecDetail = new THREE.Mesh(new THREE.SphereGeometry(0.1, 14, 12), darkFurMaterial);
                pecDetail.scale.set(1, 0.6, 1.1);
                pecDetail.position.set(0.26 * side, 1.7, 0.42);
                group.add(pecDetail);
            }

            // Abdominais definidos
            for (let i = 0; i < 4; i++) {
                const ab = new THREE.Mesh(new THREE.BoxGeometry(0.35 - i * 0.05, 0.08, 0.15, 6), darkFurMaterial);
                ab.position.set(0, 1.15 - i * 0.12, 0.32);
                ab.scale.z = 0.8;
                group.add(ab);
            }

            // Cintura/pelve mais definida, elegante e musculosa
            const pelvis = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.58, 0.55, 28), furMaterial);
            pelvis.position.y = 0.86;
            pelvis.scale.z = 0.92;
            group.add(pelvis);
            
            // Detalhes de pelagem no corpo
            for (let i = 0; i < 12; i++) {
                const bodyFur = new THREE.Mesh(
                    new THREE.ConeGeometry(0.025 + Math.random() * 0.02, 0.1 + Math.random() * 0.06, 8),
                    Math.random() > 0.5 ? darkFurMaterial : furMaterial
                );
                bodyFur.position.set(
                    (Math.random() - 0.5) * 0.6,
                    0.9 + Math.random() * 0.8,
                    0.28 + Math.random() * 0.12
                );
                bodyFur.rotation.z = (Math.random() - 0.5) * 0.5;
                bodyFur.rotation.y = (Math.random() - 0.5) * 0.3;
                group.add(bodyFur);
            }

            // CabeÃ§a de leÃ£o muito mais realista e majestosa - mais volumosa
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.55, 32, 30), furMaterial);
            head.scale.set(1.2, 1.0, 1.3);
            head.position.set(0, 2.6, 0.38);
            head.rotation.x = -0.08;
            group.add(head);
            
            // Testa mais larga, majestosa e imponente
            const forehead = new THREE.Mesh(new THREE.SphereGeometry(0.24, 20, 18), furMaterial);
            forehead.position.set(0, 2.75, 0.25);
            forehead.scale.set(1.9, 0.85, 1.05);
            group.add(forehead);
            
            // Detalhes de pelo na testa
            for (let i = 0; i < 6; i++) {
                const foreheadFur = new THREE.Mesh(
                    new THREE.ConeGeometry(0.025 + Math.random() * 0.015, 0.08 + Math.random() * 0.05, 8),
                    Math.random() > 0.6 ? darkFurMaterial : furMaterial
                );
                foreheadFur.position.set(
                    (Math.random() - 0.5) * 0.35,
                    2.82 + Math.random() * 0.05,
                    0.18 + Math.random() * 0.08
                );
                foreheadFur.rotation.z = (Math.random() - 0.5) * 0.3;
                group.add(foreheadFur);
            }
            
            // Bochechas muito mais definidas e volumosas
            for (const side of [-1, 1]) {
                const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.22, 20, 18), darkFurMaterial);
                cheek.scale.set(1.1, 0.8, 1.3);
                cheek.position.set(0.32 * side, 2.45, 0.45);
                group.add(cheek);
                
                // Detalhe da bochecha
                const cheekDetail = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 14), darkFurMaterial);
                cheekDetail.scale.set(1, 0.7, 1.1);
                cheekDetail.position.set(0.3 * side, 2.42, 0.5);
                group.add(cheekDetail);
            }
            
            // MandÃ­bula mais pronunciada
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.16, 0.32, 8), darkFurMaterial);
            jaw.position.set(0, 2.35, 0.5);
            jaw.scale.z = 0.9;
            group.add(jaw);

            // Juba totalmente lisa e majestosa - muito mais volumosa e imponente
            // Usando apenas esferas e cilindros grandes e suaves com mais camadas
            
            // Camada principal da juba - forma esfÃ©rica lisa ao redor da cabeÃ§a (mais volumosa)
            const maneMain = new THREE.Mesh(
                new THREE.SphereGeometry(0.92, 64, 64),
                maneMaterial
            );
            maneMain.position.set(0, 2.32, 0);
            maneMain.scale.set(1.05, 1.15, 1.05);
            group.add(maneMain);
            
            // Camada externa lisa adicional (mais volumosa)
            const maneOuter = new THREE.Mesh(
                new THREE.SphereGeometry(0.98, 64, 64),
                new THREE.MeshStandardMaterial({ 
                    color: 0x7a5a3a,
                    roughness: 0.85,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.65
                })
            );
            maneOuter.position.set(0, 2.27, 0);
            maneOuter.scale.set(1.08, 1.1, 1.08);
            group.add(maneOuter);
            
            // Camada interna (mais escura) para profundidade
            const maneInner = new THREE.Mesh(
                new THREE.SphereGeometry(0.86, 64, 64),
                darkFurMaterial
            );
            maneInner.position.set(0, 2.34, -0.05);
            maneInner.scale.set(1, 1.1, 0.95);
            group.add(maneInner);
            
            // Juba frontal completamente lisa - cilindro grande e mais volumoso
            const frontManeMain = new THREE.Mesh(
                new THREE.CylinderGeometry(0.75, 0.82, 0.68, 64),
                maneMaterial
            );
            frontManeMain.position.set(0, 2.72, 0.22);
            group.add(frontManeMain);
            
            // Parte superior frontal lisa (mais volumosa)
            const frontManeTop = new THREE.Mesh(
                new THREE.CylinderGeometry(0.78, 0.85, 0.48, 64),
                new THREE.MeshStandardMaterial({ 
                    color: 0x7a5a3a,
                    roughness: 0.88,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.7
                })
            );
            frontManeTop.position.set(0, 2.82, 0.18);
            group.add(frontManeTop);
            
            // Juba lateral completamente lisa - mais volumosa
            for (const side of [-1, 1]) {
                const sideMane = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.65, 0.72, 64),
                    maneMaterial
                );
                sideMane.position.set(0.7 * side, 2.48, 0.15);
                sideMane.rotation.y = side * Math.PI / 5;
                group.add(sideMane);
                
                // Camada extra lateral para mais volume
                const sideManeExtra = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.62, 0.67, 0.65, 64),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x7a5a3a,
                        roughness: 0.88,
                        metalness: 0.0,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                sideManeExtra.position.set(0.72 * side, 2.46, 0.12);
                sideManeExtra.rotation.y = side * Math.PI / 5.5;
                group.add(sideManeExtra);
            }

            // Focinho de leÃ£o muito mais realista e elegante
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.32, 0.55, 10), darkFurMaterial);
            snout.position.set(0, 2.42, 0.68);
            snout.rotation.x = -0.08;
            snout.scale.z = 0.95;
            group.add(snout);
            
            // Parte superior do focinho mais definida
            const snoutTop = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.2, 0.42, 10), furMaterial);
            snoutTop.position.set(0, 2.54, 0.62);
            group.add(snoutTop);
            
            // Ãrea entre o focinho e a testa (ponte nasal)
            const snoutBridge = new THREE.Mesh(new THREE.BoxGeometry(0.36, 0.14, 0.32, 10), furMaterial);
            snoutBridge.position.set(0, 2.62, 0.52);
            group.add(snoutBridge);

            // Nariz muito mais detalhado
            const nose = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.12, 0.14, 8), noseMaterial);
            nose.position.set(0, 2.36, 0.82);
            nose.scale.set(1, 0.9, 1.1);
            group.add(nose);
            
            // Narinas mais realistas - formato ovalado
            for (const side of [-1, 1]) {
                const nostril = new THREE.Mesh(new THREE.SphereGeometry(0.05, 12, 10),
                    new THREE.MeshStandardMaterial({ color: 0x1a0a0a, roughness: 0.25, metalness: 0.05 }));
                nostril.position.set(side * 0.055, 2.36, 0.84);
                nostril.scale.set(0.9, 0.8, 1.2);
                group.add(nostril);
            }
            
            // LÃ¡bio superior
            const upperLip = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.06, 0.12, 6), darkFurMaterial);
            upperLip.position.set(0, 2.28, 0.8);
            group.add(upperLip);
            
            // LÃ¡bio inferior
            const lowerLip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.1, 6), darkFurMaterial);
            lowerLip.position.set(0, 2.22, 0.78);
            group.add(lowerLip);

            // Olhos muito mais expressivos, intensos e majestosos
            for (const side of [-1, 1]) {
                // Olho principal maior e muito mais expressivo
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.18, 24, 22), eyeMaterial);
                eye.position.set(0.24 * side, 2.6, 0.54);
                eye.scale.set(1.15, 1, 1.1);
                group.add(eye);
                
                // Ãris dourada mais vibrante e brilhante
                const iris = new THREE.Mesh(new THREE.SphereGeometry(0.13, 20, 18),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd500, 
                        roughness: 0.25,
                        metalness: 0.5,
                        emissive: 0xffaa00,
                        emissiveIntensity: 0.3
                    }));
                iris.position.set(0.24 * side, 2.6, 0.57);
                group.add(iris);
                
                // Brilho no olho mais intenso e realista (reflexo)
                const eyeGlow = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 14),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff,
                        emissiveIntensity: 1.5
                    }));
                eyeGlow.position.set(0.26 * side, 2.62, 0.56);
                group.add(eyeGlow);
                
                // Segundo reflexo menor
                const eyeGlow2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 12, 10),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff,
                        emissiveIntensity: 1.0
                    }));
                eyeGlow2.position.set(0.27 * side, 2.61, 0.55);
                group.add(eyeGlow2);
                
                // Pupila maior e mais definida
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.1, 20, 18),
                    new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.05 }));
                pupil.position.set(0.25 * side, 2.61, 0.58);
                group.add(pupil);
                
                // Sobrancelha/Ã¡rea acima do olho mais definida
                const eyebrow = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.06, 0.12, 6),
                    darkFurMaterial);
                eyebrow.position.set(0.24 * side, 2.68, 0.48);
                eyebrow.rotation.z = side * 0.15;
                eyebrow.scale.z = 0.85;
                group.add(eyebrow);
                
                // PÃ¡lpebra superior
                const eyelid = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.04, 0.1, 6),
                    darkFurMaterial);
                eyelid.position.set(0.24 * side, 2.64, 0.49);
                group.add(eyelid);
                
                // PÃ¡lpebra inferior
                const lowerEyelid = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.03, 0.08, 6),
                    darkFurMaterial);
                lowerEyelid.position.set(0.24 * side, 2.52, 0.5);
                group.add(lowerEyelid);
            }

            // Orelhas de leÃ£o mais bonitas e realistas
            for (const side of [-1, 1]) {
                // Orelha externa
                const ear = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.38, 12), furMaterial);
                ear.position.set(0.35 * side, 2.65, 0.22);
                ear.rotation.z = -side * Math.PI / 4.2;
                ear.rotation.x = -0.18;
                group.add(ear);
                
                // Parte interna da orelha (mais clara)
                const earInner = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.25, 10),
                    new THREE.MeshStandardMaterial({ color: 0xf0d0a0, roughness: 0.8 }));
                earInner.position.set(0.36 * side, 2.63, 0.25);
                earInner.rotation.z = -side * Math.PI / 4.2;
                earInner.rotation.x = -0.18;
                group.add(earInner);
            }

            // Cauda de leÃ£o com tufo mais volumoso e majestoso
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.16, 1.1, 16), furMaterial);
            tail.position.set(0, 0.98, -0.58);
            tail.rotation.x = -Math.PI / 2.6;
            tail.rotation.z = 0.08;
            group.add(tail);
            
            // Detalhes de pelo na cauda
            for (let i = 0; i < 8; i++) {
                const tailFur = new THREE.Mesh(
                    new THREE.ConeGeometry(0.02 + Math.random() * 0.015, 0.06 + Math.random() * 0.04, 8),
                    Math.random() > 0.5 ? darkFurMaterial : furMaterial
                );
                const t = i / 8;
                tailFur.position.set(
                    (Math.random() - 0.5) * 0.1,
                    0.95 - t * 0.6,
                    -0.55 - t * 0.35
                );
                tailFur.rotation.z = (Math.random() - 0.5) * 0.4;
                group.add(tailFur);
            }
            
            // Tufo na ponta da cauda (muito mais volumoso e majestoso)
            const tailTuft = new THREE.Mesh(new THREE.SphereGeometry(0.15, 14, 14), maneMaterial);
            tailTuft.position.set(0, 0.35, -0.95);
            tailTuft.scale.set(1.1, 1.2, 1.0);
            group.add(tailTuft);
            
            // Camada extra do tufo
            const tailTuftExtra = new THREE.Mesh(new THREE.SphereGeometry(0.17, 14, 14), 
                new THREE.MeshStandardMaterial({ 
                    color: 0x7a5a3a,
                    roughness: 0.88,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.7
                })
            );
            tailTuftExtra.position.set(0, 0.32, -0.97);
            tailTuftExtra.scale.set(1.15, 1.1, 1.05);
            group.add(tailTuftExtra);

            // BraÃ§os humanos de leÃ£o - muito mais visÃ­veis, fortes e majestosos
            for (const side of [-1, 1]) {
                // Ombro mais volumoso, visÃ­vel e imponente
                const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.26, 20, 18), furMaterial);
                shoulder.position.set(0.6 * side, 2.02, 0);
                shoulder.scale.set(1.05, 1.25, 1.0);
                group.add(shoulder);
                
                // Detalhes de pelo no ombro
                for (let i = 0; i < 5; i++) {
                    const shoulderFur = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02 + Math.random() * 0.015, 0.08 + Math.random() * 0.05, 8),
                        Math.random() > 0.5 ? darkFurMaterial : furMaterial
                    );
                    shoulderFur.position.set(
                        0.58 * side + (Math.random() - 0.5) * 0.15,
                        1.95 + Math.random() * 0.2,
                        0.05 + Math.random() * 0.08
                    );
                    shoulderFur.rotation.z = (Math.random() - 0.5) * 0.4;
                    group.add(shoulderFur);
                }
                
                // Detalhe do ombro - parte superior
                const shoulderTop = new THREE.Mesh(new THREE.SphereGeometry(0.18, 14, 12), darkFurMaterial);
                shoulderTop.position.set(0.59 * side, 2.12, 0.08);
                shoulderTop.scale.set(1, 0.8, 0.9);
                group.add(shoulderTop);

                // BraÃ§o superior muito musculado e visÃ­vel
                const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.19, 0.24, 1.1, 24), armMaterial);
                upperArm.position.set(0.62 * side, 1.5, 0);
                upperArm.rotation.z = side * Math.PI / 10;
                group.add(upperArm);

                // BÃ­ceps muito definido e proeminente
                const bicep = new THREE.Mesh(new THREE.SphereGeometry(0.17, 16, 14), darkFurMaterial);
                bicep.position.set(0.63 * side, 1.38, 0.12);
                bicep.scale.set(1, 1.5, 0.9);
                group.add(bicep);
                
                // TrÃ­ceps definido
                const tricep = new THREE.Mesh(new THREE.SphereGeometry(0.14, 14, 12), darkFurMaterial);
                tricep.position.set(0.62 * side, 1.42, -0.08);
                tricep.scale.set(1, 1.2, 0.8);
                group.add(tricep);

                // Cotovelo mais pronunciado
                const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.16, 16, 14), armMaterial);
                elbow.position.set(0.66 * side, 1.0, 0.1);
                elbow.scale.set(1, 0.9, 0.9);
                group.add(elbow);

                // AntebraÃ§o muito musculado e visÃ­vel
                const foreArm = new THREE.Mesh(new THREE.CylinderGeometry(0.17, 0.2, 1.12, 24), armMaterial);
                foreArm.position.set(0.72 * side, 0.44, 0.16);
                foreArm.rotation.z = side * Math.PI / 16;
                group.add(foreArm);
                
                // MÃºsculo do antebraÃ§o (flexor)
                const forearmMuscle = new THREE.Mesh(new THREE.SphereGeometry(0.13, 14, 12), darkFurMaterial);
                forearmMuscle.position.set(0.73 * side, 0.5, 0.2);
                forearmMuscle.scale.set(1, 1.3, 0.85);
                group.add(forearmMuscle);

                // Pulso mais definido
                const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.13, 14, 12), armMaterial);
                wrist.position.set(0.76 * side, -0.08, 0.18);
                group.add(wrist);

                // Pata/mÃ£o de leÃ£o com garras muito mais visÃ­veis
                const paw = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.28, 0.38, 14), pawMaterial);
                paw.position.set(0.78 * side, -0.18, 0.22);
                paw.rotation.z = side * Math.PI / 25;
                group.add(paw);
                
                // Palma da mÃ£o mais definida
                const palm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.3, 10), pawMaterial);
                palm.position.set(0.78 * side, -0.25, 0.2);
                palm.rotation.z = side * Math.PI / 28;
                group.add(palm);
                
                // Dedos/garras mais visÃ­veis e realistas
                for (let i = 0; i < 4; i++) {
                    // Dedos
                    const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.12, 8), pawMaterial);
                    finger.position.set(0.8 * side, -0.15 + i * 0.05, 0.32);
                    finger.rotation.z = side * Math.PI / 20;
                    finger.rotation.x = Math.PI / 2.8;
                    group.add(finger);
                    
                    // Garras nas pontas dos dedos
                    const claw = new THREE.Mesh(new THREE.ConeGeometry(0.035, 0.1, 8),
                        new THREE.MeshStandardMaterial({ color: 0x6a4a3a, roughness: 0.5, metalness: 0.25 }));
                    claw.position.set(0.81 * side, -0.12 + i * 0.05, 0.38);
                    claw.rotation.x = Math.PI / 2.4;
                    claw.rotation.z = side * 0.2;
                    group.add(claw);
                }
                
                // Polegar
                const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.055, 0.14, 8), pawMaterial);
                thumb.position.set(0.82 * side, -0.28, 0.24);
                thumb.rotation.z = side * Math.PI / 8;
                thumb.rotation.x = Math.PI / 3;
                group.add(thumb);
                
                // Garra do polegar
                const thumbClaw = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.11, 8),
                    new THREE.MeshStandardMaterial({ color: 0x6a4a3a, roughness: 0.5, metalness: 0.25 }));
                thumbClaw.position.set(0.83 * side, -0.25, 0.28);
                thumbClaw.rotation.x = Math.PI / 2.3;
                thumbClaw.rotation.z = side * 0.25;
                group.add(thumbClaw);
            }

            // Pernas bÃ­pedes muito mais fortes, musculadas e imponentes
            for (const side of [-1, 1]) {
                // Quadril mais robusto e musculoso
                const hip = new THREE.Mesh(new THREE.SphereGeometry(0.23, 18, 16), furMaterial);
                hip.position.set(0.34 * side, 0.8, 0);
                hip.scale.set(1.05, 1.2, 0.92);
                group.add(hip);
                
                // Detalhes de pelo no quadril
                for (let i = 0; i < 4; i++) {
                    const hipFur = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02 + Math.random() * 0.015, 0.07 + Math.random() * 0.04, 8),
                        Math.random() > 0.5 ? darkFurMaterial : furMaterial
                    );
                    hipFur.position.set(
                        0.32 * side + (Math.random() - 0.5) * 0.12,
                        0.75 + Math.random() * 0.15,
                        0.02 + Math.random() * 0.06
                    );
                    hipFur.rotation.z = (Math.random() - 0.5) * 0.3;
                    group.add(hipFur);
                }

                // Coxa muito musculada
                const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.26, 1.05, 24), armMaterial);
                thigh.position.set(0.34 * side, 0.28, 0);
                thigh.rotation.x = 0.12;
                group.add(thigh);

                // QuadrÃ­ceps muito definido
                const quad = new THREE.Mesh(new THREE.SphereGeometry(0.18, 14, 12), darkFurMaterial);
                quad.position.set(0.35 * side, 0.4, 0.1);
                quad.scale.set(1, 1.5, 0.75);
                group.add(quad);

                // Joelho
                const knee = new THREE.Mesh(new THREE.SphereGeometry(0.18, 14, 12), armMaterial);
                knee.position.set(0.37 * side, -0.23, 0);
                knee.scale.set(1, 0.95, 0.9);
                group.add(knee);

                // Canela musculada
                const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.19, 0.22, 0.88, 24), armMaterial);
                shin.position.set(0.4 * side, -0.65, 0);
                shin.rotation.x = -0.06;
                group.add(shin);

                // Tornozelo
                const ankle = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 10), armMaterial);
                ankle.position.set(0.41 * side, -1.05, 0.06);
                group.add(ankle);

                // Pata de leÃ£o com garras mais realistas
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.18, 0.42, 12), pawMaterial);
                foot.position.set(0.42 * side, -1.15, 0.15);
                foot.rotation.x = Math.PI / 14;
                group.add(foot);
                
                // Dedos/garras
                for (let i = 0; i < 4; i++) {
                    const claw = new THREE.Mesh(new THREE.ConeGeometry(0.035, 0.1, 6),
                        new THREE.MeshStandardMaterial({ color: 0x6a4a3a, roughness: 0.5, metalness: 0.2 }));
                    claw.position.set(0.43 * side, -1.17 + i * 0.045, 0.28);
                    claw.rotation.x = Math.PI / 2.8;
                    claw.rotation.z = side * 0.12;
                    group.add(claw);
                }
            }

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function criarModeloCobra() {
            const group = new THREE.Group();
            const scaleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5a8a6a, 
                roughness: 0.75,
                metalness: 0.08
            });
            const darkScaleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5a4a, 
                roughness: 0.78,
                metalness: 0.1
            });
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff3333,
                emissiveIntensity: 0.7,
                roughness: 0.3
            });
            const tongueMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                roughness: 0.4
            });

            // Corpo longo (serpente) - mais segmentos e mais realista
            const bodySegments = 12;
            for (let i = 0; i < bodySegments; i++) {
                const segment = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.22 - i * 0.015, 0.24 - i * 0.015, 0.45, 14),
                    i % 2 === 0 ? scaleMaterial : darkScaleMaterial // PadrÃ£o de escamas
                );
                segment.position.set(0, 0.35, -i * 0.38);
                segment.rotation.z = Math.sin(i * 0.25) * 0.15;
                segment.castShadow = true;
                segment.receiveShadow = true;
                group.add(segment);
            }

            // CabeÃ§a triangular de cobra mais realista
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.28, 0.5, 8), scaleMaterial);
            head.rotation.x = Math.PI / 2;
            head.position.set(0, 0.35, 0.5);
            group.add(head);

            // Parte superior da cabeÃ§a
            const headTop = new THREE.Mesh(new THREE.SphereGeometry(0.22, 14, 12), scaleMaterial);
            headTop.scale.set(1.2, 0.6, 1.0);
            headTop.position.set(0, 0.5, 0.4);
            group.add(headTop);

            // Olhos de cobra mais realistas
            for (const side of [-1, 1]) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), eyeMaterial);
                eye.position.set(0.12 * side, 0.48, 0.52);
                group.add(eye);
            }

            // LÃ­ngua bifurcada mais realista
            const tongueBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.04, 0.12, 6),
                tongueMaterial
            );
            tongueBase.position.set(0, 0.38, 0.7);
            tongueBase.rotation.x = Math.PI / 2;
            group.add(tongueBase);
            
            for (const side of [-1, 1]) {
                const tongueFork = new THREE.Mesh(
                    new THREE.ConeGeometry(0.015, 0.18, 6),
                    tongueMaterial
                );
                tongueFork.position.set(side * 0.03, 0.38, 0.82);
                tongueFork.rotation.x = Math.PI / 2;
                tongueFork.rotation.z = side * Math.PI / 8;
                group.add(tongueFork);
            }

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function criarModeloCavalo() {
            const group = new THREE.Group();
            // Materiais mais realistas e vibrantes
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x956b4a, 
                roughness: 0.85,
                metalness: 0.01
            });
            const darkBodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7a543c, 
                roughness: 0.87,
                metalness: 0.01
            });
            const maneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a0f08, 
                roughness: 0.92,
                metalness: 0.0
            });
            const hoofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0806, 
                roughness: 0.45,
                metalness: 0.12
            });
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x855a3c, 
                roughness: 0.85,
                metalness: 0.01
            });
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0x6a4422,
                emissive: 0x8a5522,
                emissiveIntensity: 0.8,
                roughness: 0.25,
                metalness: 0.15
            });
            const noseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6a4a2a, 
                roughness: 0.6,
                metalness: 0.08
            });

            // Corpo de cavalo quadrÃºpede - proporÃ§Ãµes realistas de equino
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.72, 2.2, 28), bodyMaterial);
            torso.position.y = 0.75;
            torso.rotation.x = Math.PI / 2;
            torso.scale.z = 0.9;
            group.add(torso);

            // Peito muito musculoso e imponente (cavalo quadrÃºpede)
            const chest = new THREE.Mesh(new THREE.CylinderGeometry(0.62, 0.68, 1.3, 28), darkBodyMaterial);
            chest.position.set(0.5, 0.75, 0.22);
            chest.rotation.x = Math.PI / 2;
            chest.scale.z = 0.9;
            group.add(chest);
            
            // MÃºsculos do peito definidos
            for (const side of [-1, 1]) {
                const pec = new THREE.Mesh(new THREE.SphereGeometry(0.13, 16, 14), darkBodyMaterial);
                pec.scale.set(1.05, 0.7, 1.25);
                pec.position.set(0.27 * side + 0.5, 0.75, 0.35);
                group.add(pec);
            }

            // Garupa (parte traseira do cavalo)
            const rump = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.55, 0.9, 24), bodyMaterial);
            rump.position.set(-0.5, 0.75, 0);
            rump.rotation.x = Math.PI / 2;
            rump.scale.z = 0.9;
            group.add(rump);

            // PescoÃ§o de cavalo mais longo, elegante e arqueado (caracterÃ­stica equina) - posiÃ§Ã£o quadrÃºpede
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.42, 1.35, 28), bodyMaterial);
            neck.position.set(0.68, 1.35, 0.38);
            neck.rotation.z = Math.PI / 3.2;
            neck.rotation.y = -0.12;
            group.add(neck);

            // Base do pescoÃ§o mais definida
            const neckBase = new THREE.Mesh(new THREE.CylinderGeometry(0.42, 0.55, 0.32, 24), darkBodyMaterial);
            neckBase.position.set(0.42, 1.0, 0.28);
            neckBase.rotation.x = Math.PI / 2.5;
            group.add(neckBase);

            // CabeÃ§a de cavalo muito mais realista - alongada e caracterÃ­stica equina (posiÃ§Ã£o quadrÃºpede)
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 26, 24), bodyMaterial);
            head.scale.set(1.2, 0.92, 1.4);
            head.position.set(1.42, 1.8, 0.48);
            head.rotation.y = -0.08;
            head.rotation.x = -0.05;
            group.add(head);

            // Testa de cavalo (Ã¡rea entre os olhos) mais pronunciada
            const forehead = new THREE.Mesh(new THREE.SphereGeometry(0.18, 18, 16), bodyMaterial);
            forehead.position.set(1.15, 1.9, 0.38);
            forehead.scale.set(1.9, 1.1, 1.0);
            group.add(forehead);
            
            // Bochechas mais definidas
            for (const side of [-1, 1]) {
                const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 14), darkBodyMaterial);
                cheek.scale.set(1, 0.8, 1.2);
                cheek.position.set(1.3 + 0.18 * side, 1.65, 0.45);
                group.add(cheek);
            }

            // Focinho de cavalo muito mais realista - longo e caracterÃ­stico equino
            const muzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.35, 0.85, 24), darkBodyMaterial);
            muzzle.position.set(1.78, 1.5, 0.68);
            muzzle.rotation.x = Math.PI / 2;
            muzzle.rotation.y = -0.04;
            muzzle.scale.z = 0.92;
            group.add(muzzle);

            // Parte superior do focinho (canhÃ£o) mais definida
            const muzzleTop = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.22, 0.5, 10), bodyMaterial);
            muzzleTop.position.set(1.78, 1.65, 0.62);
            group.add(muzzleTop);
            
            // Ãrea do focinho mais estreita (caracterÃ­stica equina)
            const muzzleNarrow = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.16, 0.38, 10), darkBodyMaterial);
            muzzleNarrow.position.set(1.82, 1.45, 0.72);
            group.add(muzzleNarrow);

            // Narinas muito grandes e expressivas (caracterÃ­stica equina)
            for (const side of [-1, 1]) {
                const nostril = new THREE.Mesh(new THREE.SphereGeometry(0.09, 14, 12), 
                    new THREE.MeshStandardMaterial({ color: 0x1a0a0a, roughness: 0.2, metalness: 0.08 }));
                nostril.position.set(1.75, 1.5, 0.68 + side * 0.12);
                nostril.scale.set(1.05, 1.3, 1.1);
                group.add(nostril);
                
                // Detalhe interno da narina
                const nostrilInner = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 10),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.15 }));
                nostrilInner.position.set(1.76, 1.5, 0.69 + side * 0.12);
                group.add(nostrilInner);
            }
            
            // LÃ¡bio superior muito mais pronunciado (caracterÃ­stica equina)
            const upperLip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.12, 0.18, 8), noseMaterial);
            upperLip.position.set(1.85, 1.4, 0.78);
            upperLip.rotation.x = -0.05;
            group.add(upperLip);
            
            // LÃ¡bio inferior
            const lowerLip = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.1, 0.15, 8),
                new THREE.MeshStandardMaterial({ color: 0x5a3a2a, roughness: 0.7 }));
            lowerLip.position.set(1.85, 1.3, 0.75);
            group.add(lowerLip);

            // Crina de cavalo muito mais volumosa e realista - cai ao longo do pescoÃ§o (posiÃ§Ã£o quadrÃºpede)
            const maneSegments = 16;
            for (let i = 0; i < maneSegments; i++) {
                const t = i / maneSegments;
                const neckPos = 0.32 + t * 1.0;
                const height = 1.25 + t * 0.65;
                
                // Mais fios de crina por segmento para volume mÃ¡ximo
                for (let strand = 0; strand < 5; strand++) {
                    const maneStrand = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05 + Math.random() * 0.03, 0.06 + Math.random() * 0.03, 0.4 + Math.random() * 0.2, 10),
                        maneMaterial
                    );
                    maneStrand.position.set(
                        neckPos * 0.42 + (Math.random() - 0.5) * 0.12,
                        height + (Math.random() - 0.5) * 0.1,
                        -0.12 + (Math.random() - 0.5) * 0.06
                    );
                    maneStrand.rotation.set(
                        Math.PI / 2 + (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.3
                    );
                    group.add(maneStrand);
                }
            }
            
            // Franja na testa muito mais volumosa
            for (let i = 0; i < 10; i++) {
                const forelock = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04 + Math.random() * 0.03, 0.05 + Math.random() * 0.03, 0.3 + Math.random() * 0.15, 10),
                    maneMaterial
                );
                forelock.position.set(
                    1.12 + (Math.random() - 0.5) * 0.25,
                    2.0 + Math.random() * 0.12,
                    0.38 + Math.random() * 0.12
                );
                forelock.rotation.set(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.3
                );
                group.add(forelock);
            }

            // Orelhas de cavalo mais realistas - pontiagudas e mÃ³veis
            for (const side of [-1, 1]) {
                // Orelha externa
                const ear = new THREE.Mesh(new THREE.ConeGeometry(0.14, 0.4, 12), bodyMaterial);
                ear.position.set(1.1 + 0.2 * side, 1.92, 0.38);
                ear.rotation.z = -side * Math.PI / 5;
                ear.rotation.x = -0.25;
                ear.rotation.y = side * 0.1;
                group.add(ear);
                
                // Parte interna da orelha (mais clara)
                const earInner = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3, 10),
                    new THREE.MeshStandardMaterial({ color: 0x6a4a2a, roughness: 0.7 }));
                earInner.position.set(1.12 + 0.2 * side, 1.9, 0.4);
                earInner.rotation.z = -side * Math.PI / 5;
                earInner.rotation.x = -0.25;
                group.add(earInner);
            }

            // Olhos de cavalo muito mais expressivos e realistas
            for (const side of [-1, 1]) {
                // Olho principal maior e mais expressivo
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.13, 20, 18), eyeMaterial);
                eye.position.set(1.05 + 0.18 * side, 1.74, 0.52);
                eye.scale.set(1.15, 1, 1.1);
                group.add(eye);
                
                // Ãris
                const iris = new THREE.Mesh(new THREE.SphereGeometry(0.1, 18, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8a5522, 
                        roughness: 0.35,
                        metalness: 0.2
                    }));
                iris.position.set(1.05 + 0.18 * side, 1.74, 0.55);
                group.add(iris);
                
                // Pupila
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 14),
                    new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 }));
                pupil.position.set(1.06 + 0.18 * side, 1.74, 0.56);
                group.add(pupil);
                
                // Brilho no olho mais intenso
                const eyeGlow = new THREE.Mesh(new THREE.SphereGeometry(0.05, 12, 10),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff,
                        emissiveIntensity: 0.8
                    }));
                eyeGlow.position.set(1.07 + 0.18 * side, 1.76, 0.54);
                group.add(eyeGlow);
                
                // PÃ¡lpebra superior
                const eyelid = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.03, 0.1, 6),
                    darkBodyMaterial);
                eyelid.position.set(1.05 + 0.18 * side, 1.78, 0.5);
                group.add(eyelid);
                
                // Sobrancelha
                const eyebrow = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.05, 0.08, 6),
                    darkBodyMaterial);
                eyebrow.position.set(1.05 + 0.18 * side, 1.84, 0.48);
                eyebrow.rotation.z = side * 0.1;
                group.add(eyebrow);
            }

            // Cauda de cavalo mais volumosa (posiÃ§Ã£o quadrÃºpede)
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.18, 1.15, 14), maneMaterial);
            tail.position.set(-0.6, 0.75, -0.55);
            tail.rotation.x = -Math.PI / 2.5;
            tail.rotation.z = 0.1;
            group.add(tail);

            // 4 PERNAS DE CAVALO - PosiÃ§Ãµes realistas de equino quadrÃºpede
            // Patas dianteiras (mais prÃ³ximas da cabeÃ§a)
            for (const side of [-1, 1]) {
                // Omoplata (scapula)
                const scapula = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 14), bodyMaterial);
                scapula.position.set(0.4 * side, 1.1, -0.15);
                scapula.scale.set(1, 1.2, 0.9);
                group.add(scapula);

                // BraÃ§o superior (ombro atÃ© cotovelo)
                const upperLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.95, 22), armMaterial);
                upperLeg.position.set(0.42 * side, 0.6, -0.1);
                upperLeg.rotation.z = side * Math.PI / 18;
                group.add(upperLeg);

                // Cotovelo
                const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.16, 14, 12), armMaterial);
                elbow.position.set(0.45 * side, 0.15, -0.05);
                group.add(elbow);

                // AntebraÃ§o (canela dianteira)
                const foreLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.19, 1.0, 22), armMaterial);
                foreLeg.position.set(0.48 * side, -0.4, 0);
                foreLeg.rotation.z = side * Math.PI / 24;
                group.add(foreLeg);

                // Casco dianteiro
                const frontHoof = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.18, 0.45, 12), hoofMaterial);
                frontHoof.position.set(0.5 * side, -0.9, 0.15);
                frontHoof.rotation.x = Math.PI / 12;
                group.add(frontHoof);
                
                // Detalhe do casco dianteiro - parte frontal
                const frontHoofFront = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.16, 0.12, 8), hoofMaterial);
                frontHoofFront.position.set(0.5 * side, -0.88, 0.35);
                frontHoofFront.rotation.x = Math.PI / 8;
                group.add(frontHoofFront);
            }

            // Patas traseiras (mais prÃ³ximas da cauda)
            for (const side of [-1, 1]) {
                // Quadril (garupa)
                const hip = new THREE.Mesh(new THREE.SphereGeometry(0.24, 16, 14), bodyMaterial);
                hip.position.set(-0.4 * side, 1.05, -0.1);
                hip.scale.set(1, 1.2, 0.95);
                group.add(hip);

                // Coxa traseira (muito musculada)
                const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.26, 1.05, 26), armMaterial);
                thigh.position.set(-0.42 * side, 0.55, -0.08);
                thigh.rotation.z = -side * Math.PI / 12;
                group.add(thigh);

                // QuadrÃ­ceps traseiro definido
                const quad = new THREE.Mesh(new THREE.SphereGeometry(0.19, 16, 14), darkBodyMaterial);
                quad.position.set(-0.43 * side, 0.7, 0.05);
                quad.scale.set(1, 1.4, 0.8);
                group.add(quad);

                // Joelho traseiro
                const knee = new THREE.Mesh(new THREE.SphereGeometry(0.18, 14, 12), armMaterial);
                knee.position.set(-0.45 * side, 0.05, -0.05);
                knee.scale.set(1, 0.95, 0.9);
                group.add(knee);

                // Canela traseira (muito musculada)
                const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.20, 0.23, 0.98, 26), armMaterial);
                shin.position.set(-0.48 * side, -0.45, 0);
                shin.rotation.z = -side * Math.PI / 20;
                group.add(shin);

                // Tornozelo traseiro (garrÃ£o)
                const hock = new THREE.Mesh(new THREE.SphereGeometry(0.16, 12, 10), armMaterial);
                hock.position.set(-0.5 * side, -0.95, 0.05);
                group.add(hock);

                // Casco traseiro (mais alongado que o dianteiro)
                const hindHoof = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.5, 12), hoofMaterial);
                hindHoof.position.set(-0.52 * side, -1.22, 0.18);
                hindHoof.rotation.x = Math.PI / 14;
                group.add(hindHoof);
                
                // Detalhe do casco traseiro - parte frontal
                const hindHoofFront = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.18, 0.15, 8), hoofMaterial);
                hindHoofFront.position.set(-0.52 * side, -1.2, 0.4);
                hindHoofFront.rotation.x = Math.PI / 10;
                group.add(hindHoofFront);
            }

            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            return group;
        }

        function criarCenaCutsceneFinal() {
            const scene = gameState.scene;
            clearScene();

            // Ambiente noturno com cidade ao fundo
            scene.background = new THREE.Color(0x0a0d15);
            scene.fog = new THREE.FogExp2(0x0a0d15, 0.08);

            // IluminaÃ§Ã£o dramÃ¡tica para a luta
            const mainLight = new THREE.DirectionalLight(0xffd9a3, 1.5);
            mainLight.position.set(5, 12, 8);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -15;
            mainLight.shadow.camera.right = 15;
            mainLight.shadow.camera.top = 15;
            mainLight.shadow.camera.bottom = -15;
            scene.add(mainLight);

            const rimLight = new THREE.PointLight(0xffaa44, 1.2, 30, 1.5);
            rimLight.position.set(-8, 8, -5);
            scene.add(rimLight);

            const ambientFill = new THREE.HemisphereLight(0x2a3a4f, 0x0a0d15, 0.6);
            scene.add(ambientFill);

            // ChÃ£o com textura de estrada/cidade
            const floor = createGround(30, 25, 0x1a1a1f);
            scene.add(floor);

            // Muros/portÃµes da cidade ao fundo
            const cityWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 1.5),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2f, 
                    roughness: 0.85,
                    metalness: 0.1
                })
            );
            cityWall.position.set(0, 4, -10);
            cityWall.castShadow = true;
            cityWall.receiveShadow = true;
            scene.add(cityWall);

            // PortÃµes da cidade
            const gateLeft = new THREE.Mesh(
                new THREE.BoxGeometry(2, 6, 0.3),
                new THREE.MeshStandardMaterial({ 
                    color: 0x3a2a1a, 
                    roughness: 0.8,
                    metalness: 0.2
                })
            );
            gateLeft.position.set(-3, 3, -9.8);
            gateLeft.castShadow = true;
            scene.add(gateLeft);

            const gateRight = gateLeft.clone();
            gateRight.position.x = 3;
            scene.add(gateRight);

            // Janelas iluminadas na parede da cidade
            for (let i = -2; i <= 2; i++) {
                const window = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffd28b,
                        emissive: 0xffaa44,
                        emissiveIntensity: 1.2
                    })
                );
                window.position.set(i * 2.5, 5, -9.5);
                scene.add(window);
            }

            // NÃ©voa no chÃ£o
            const fogLayer = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 25),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a2f, 
                    transparent: true, 
                    opacity: 0.3 
                })
            );
            fogLayer.position.y = 0.1;
            fogLayer.rotation.x = -Math.PI / 2;
            scene.add(fogLayer);

            // CÃ¢mera inicial - vista lateral da arena
            setCameraPose(new THREE.Vector3(0, 3.5, 8), new THREE.Vector3(0, 1.5, -3));
            scene.userData.cameraBase = new THREE.Vector3(0, 3.5, 8);
            scene.userData.cameraLook = new THREE.Vector3(0, 1.5, -3);
            scene.userData.cameraTarget = new THREE.Vector3(0, 1.5, -3);
        }

        async function lutarBodeCavalo() {
            gameState.cena_atual = 'luta_final';
            
            // Limpar qualquer atualizaÃ§Ã£o ativa que possa interferir
            gameState.activeUpdate = null;
            
            criarCenaCutsceneFinal();
            setAmbient(null);
            const scene = gameState.scene;

            // CÃ¢mera inicial - vista dramÃ¡tica
            setCameraPose(new THREE.Vector3(0, 3.5, 8), new THREE.Vector3(0, 1.5, -3));
            mostrarDialogo('VocÃª finalmente chega Ã  cidade! Mas o Senhor Bode te alcanÃ§a...');
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Senhor Bode entra em cena
            const bode = criarModeloBode();
            bode.scale.set(1.3, 1.3, 1.3);
            bode.position.set(-4, 0, -6);
            scene.add(bode);

            const bodeGlow = new THREE.PointLight(0xfcdc6b, 2.5, 20, 1.8);
            bodeGlow.position.set(-4, 2.5, -6);
            scene.add(bodeGlow);

            mostrarDialogo('O Senhor Bode se aproxima com fÃºria, seus olhos amarelos brilhando na escuridÃ£o...');
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // AnimaÃ§Ã£o de aproximaÃ§Ã£o do Bode com rotaÃ§Ã£o
            const bodeStart = bode.position.clone();
            const bodeMid = new THREE.Vector3(-1.5, 0, -3.5);
            
            // Garantir que a animaÃ§Ã£o funcione mesmo se o loop estiver pausado
            try {
                await animateModelMove(bode, bodeStart, bodeMid, 2.0);
            } catch (error) {
                console.error('Erro na animaÃ§Ã£o do bode:', error);
                // Fallback: mover diretamente
                bode.position.copy(bodeMid);
            }
            bode.rotation.y = Math.PI / 4;
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 1000));

            // CÃ¢mera se move para mostrar melhor a aÃ§Ã£o
            await animateFirstPersonMove([
                {
                    position: new THREE.Vector3(-2, 2.8, 6),
                    lookAt: new THREE.Vector3(-1, 1.5, -3)
                }
            ], { duration: 1.5 });

            // Sr. Cavalo entra em cena
            const cavalo = criarModeloCavalo();
            cavalo.scale.set(1.2, 1.2, 1.2);
            cavalo.position.set(4, 0, -6);
            scene.add(cavalo);

            const cavaloGlow = new THREE.PointLight(0x7ec6ff, 2.0, 20, 1.8);
            cavaloGlow.position.set(4, 2.5, -6);
            scene.add(cavaloGlow);

            mostrarDialogo('De repente, o Sr. Cavalo surge em sua defesa! O confronto final comeÃ§a!');
            audioManager.playEffect('coleta');
            
            // Cavalo avanÃ§a com movimento dinÃ¢mico
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(1.5, 0, -3.5), 2.2);
            cavalo.rotation.y = -Math.PI / 4;
            await new Promise(resolve => setTimeout(resolve, 1000));

            // CÃ¢mera muda para vista frontal da luta
            await animateFirstPersonMove([
                {
                    position: new THREE.Vector3(0, 3, 5),
                    lookAt: new THREE.Vector3(0, 1.5, -3)
                }
            ], { duration: 1.5 });

            mostrarDialogo('A batalha Ã©pica entre o Senhor Bode e o Sr. Cavalo se inicia!');
            await new Promise(resolve => setTimeout(resolve, 1500));

            // SequÃªncia de luta com animaÃ§Ãµes mais dinÃ¢micas
            mostrarDialogo('O Senhor Bode ataca primeiro!');
            bode.rotation.y = Math.PI / 6;
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(0.5, 0.3, -3.8), 1.0);
            bode.position.y = 0.3; // Salto
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 300));
            bode.position.y = 0; // Aterrissa
            await new Promise(resolve => setTimeout(resolve, 700));

            mostrarDialogo('O Sr. Cavalo esquiva e contra-ataca!');
            cavalo.rotation.y = -Math.PI / 3;
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(0.2, 0, -3.5), 1.2);
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-1.2, 0, -4.2), 1.0);
            bode.rotation.y = -Math.PI / 4;
            audioManager.playEffect('coleta');
            await new Promise(resolve => setTimeout(resolve, 1000));

            mostrarDialogo('O Senhor Bode recua, mas nÃ£o desiste!');
            bode.rotation.y = Math.PI / 2;
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-0.5, 0, -3.6), 1.2);
            await new Promise(resolve => setTimeout(resolve, 800));

            mostrarDialogo('O Sr. Cavalo avanÃ§a com determinaÃ§Ã£o!');
            cavalo.rotation.y = -Math.PI / 2;
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(-0.3, 0.2, -3.6), 1.4);
            cavalo.position.y = 0.2; // Salto do cavalo
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-1.8, 0, -4.5), 1.3);
            await new Promise(resolve => setTimeout(resolve, 300));
            cavalo.position.y = 0;
            audioManager.playEffect('coleta');
            await new Promise(resolve => setTimeout(resolve, 1000));

            // CÃ¢mera se move para Ã¢ngulo mais dinÃ¢mico
            await animateFirstPersonMove([
                {
                    position: new THREE.Vector3(2, 2.5, 4),
                    lookAt: new THREE.Vector3(-0.5, 1.5, -3.5)
                }
            ], { duration: 1.2 });

            mostrarDialogo('O confronto se intensifica! Ambos lutam com todas as forÃ§as!');
            bode.rotation.y = Math.PI / 3;
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-0.8, 0.2, -3.8), 1.1);
            bode.position.y = 0.2;
            cavalo.rotation.y = -Math.PI / 4;
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(-0.5, 0, -3.7), 1.2);
            await new Promise(resolve => setTimeout(resolve, 300));
            bode.position.y = 0;
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-2.0, 0, -4.8), 1.4);
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 1200));

            // CÃ¢mera volta para vista frontal
            await animateFirstPersonMove([
                {
                    position: new THREE.Vector3(0, 3.5, 5),
                    lookAt: new THREE.Vector3(-1, 1.5, -4)
                }
            ], { duration: 1.0 });

            mostrarDialogo('O Sr. Cavalo desfere o golpe final!');
            cavalo.rotation.y = -Math.PI / 2;
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(-1.0, 0.4, -3.8), 1.6);
            cavalo.position.y = 0.4; // Salto alto
            audioManager.playEffect('coleta');
            await new Promise(resolve => setTimeout(resolve, 400));
            cavalo.position.y = 0;
            bode.rotation.y = Math.PI;
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-4.5, 0, -7.0), 1.8);
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Bode cai derrotado
            bode.rotation.x = Math.PI / 2;
            bode.position.y = -0.2;
            await new Promise(resolve => setTimeout(resolve, 1000));

            mostrarDialogo('ApÃ³s uma luta intensa, o Sr. Cavalo derrota o Senhor Bode e salva a todos!');
            scene.remove(bodeGlow);
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Remover o bode derrotado da cena
            scene.remove(bode);

            // CÃ¢mera se move para mostrar a entrada na cidade
            await animateFirstPersonMove([
                {
                    position: new THREE.Vector3(0, 2.5, 6),
                    lookAt: new THREE.Vector3(0, 1.5, -9)
                }
            ], { duration: 2.0 });

            mostrarDialogo('Com o Senhor Bode derrotado, vocÃª e o Sr. Cavalo finalmente podem entrar na cidade em seguranÃ§a.');
            await new Promise(resolve => setTimeout(resolve, 2500));

            mostrarDialogo('VocÃªs caminham em direÃ§Ã£o aos portÃµes da cidade, deixando a floresta amaldiÃ§oada para trÃ¡s...');
            cavalo.rotation.y = 0;
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(0.0, 0, -8.5), 2.5);
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('Os portÃµes da cidade se abrem, recebendo vocÃªs com seguranÃ§a e esperanÃ§a.');
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(0.0, 0, -10.5), 2.8);
            audioManager.playEffect('coleta');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('VocÃªs entram na cidade, finalmente livres da maldiÃ§Ã£o do Senhor Bode.');
            await new Promise(resolve => setTimeout(resolve, 2500));
            atualizarStats();
        }

        async function mostrarCutsceneFinal() {
            gameState.cena_atual = 'cutscene_final';
            criarCenaCutsceneFinal();
            setAmbient(null);
            const scene = gameState.scene;

            const bode = criarModeloBode();
            bode.scale.set(1.25, 1.25, 1.25);
            bode.position.set(-2.2, 0, -3);
            scene.add(bode);

            const ganso = criarModeloGanso();
            ganso.position.set(2.4, 0, -3.4);
            scene.add(ganso);

            const lobo = criarModeloLobo();
            lobo.position.set(1.2, 0, -5.2);
            scene.add(lobo);

            mostrarDialogo('O Senhor Bode encara o Sr. Ganso e o Sr. Lobo em uma batalha desesperada...');
            await animateModelMove(ganso, ganso.position.clone(), new THREE.Vector3(0.2, 0, -3.2), 1.8);
            await animateModelMove(lobo, lobo.position.clone(), new THREE.Vector3(-0.4, 0, -3.6), 1.6);
            await animateModelMove(ganso, ganso.position.clone(), new THREE.Vector3(3.5, 0, -8), 2.2);
            await animateModelMove(lobo, lobo.position.clone(), new THREE.Vector3(4, 0, -6), 1.9);
            mostrarDialogo('Apesar dos esforÃ§os dos aliados, o Senhor Bode permanece indomÃ¡vel...');
            await new Promise(resolve => setTimeout(resolve, 1800));

            scene.remove(ganso);
            scene.remove(lobo);

            const cavalo = criarModeloCavalo();
            cavalo.scale.set(1.1, 1.1, 1.1);
            cavalo.position.set(3.2, 0, -3.2);
            scene.add(cavalo);

            mostrarDialogo('EntÃ£o, o Sr. Cavalo surge para o confronto final. A esperanÃ§a renasce.');
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(0.8, 0, -3), 2.1);
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-1.2, 0, -4.2), 1.8);
            await animateModelMove(cavalo, cavalo.position.clone(), new THREE.Vector3(-1.6, 0, -3.5), 1.7);
            mostrarDialogo('ApÃ³s uma luta intensa, o Sr. Cavalo derrota o Senhor Bode e salva a todos.');
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(-4.5, 0, -7.5), 2.4);
            await new Promise(resolve => setTimeout(resolve, 2600));
            atualizarStats();
        }

        // Inicializar Three.js
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('game-canvas');

            if (!gameState.camera) {
                gameState.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / (container.offsetHeight * 0.6), 0.1, 1000);
            } else {
                gameState.camera.aspect = container.offsetWidth / (container.offsetHeight * 0.6);
                gameState.camera.updateProjectionMatrix();
            }
            gameState.camera.up.set(0, 1, 0);

            if (!gameState.renderer) {
                gameState.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                gameState.renderer.shadowMap.enabled = true;
                gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                gameState.renderer.shadowMap.autoUpdate = true;
                gameState.renderer.outputEncoding = THREE.sRGBEncoding;
                gameState.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                gameState.renderer.toneMappingExposure = 1.2;
                gameState.renderer.physicallyCorrectLights = true;
                gameState.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            }
            gameState.renderer.setPixelRatio(window.devicePixelRatio || 1);
            gameState.renderer.setSize(container.offsetWidth, container.offsetHeight * 0.6);

            gameState.scene = new THREE.Scene();

            if (!sceneHelpers.clock) {
                sceneHelpers.clock = new THREE.Clock();
            }
            sceneHelpers.clock.start();

            if (!sceneHelpers.loopStarted) {
                startRenderLoop();
                sceneHelpers.loopStarted = true;
            }
        }

        function startRenderLoop() {
            function loop() {
                if (!gameState.renderer || !gameState.scene || !gameState.camera) {
                    requestAnimationFrame(loop);
                    return;
                }

                const delta = sceneHelpers.clock ? sceneHelpers.clock.getDelta() : 0.016;

                if (gameState.player?.userData?.animate) {
                    gameState.player.userData.animate(delta);
                }

                if (gameState.cameraAnimation) {
                    updateCameraAnimation(delta);
                }

                if (typeof gameState.activeUpdate === 'function') {
                    gameState.activeUpdate(delta);
                }

                gameState.renderer.render(gameState.scene, gameState.camera);
                requestAnimationFrame(loop);
            }

            requestAnimationFrame(loop);
        }

        // Criar cena da floresta
        function criarCenaFloresta() {
            const scene = gameState.scene;
            clearScene();

            // GrÃ¡ficos melhorados estilo Forest Survival
            scene.background = new THREE.Color(0x010308);
            // Fog mais sutil e atmosfÃ©rico
            scene.fog = new THREE.FogExp2(0x0a0f1a, 0.045);

            addCommonLights(scene, { intensity: 0.75, warm: false });

            // IluminaÃ§Ã£o mais realista estilo The Forest
            const moonLight = new THREE.DirectionalLight(0x1a2d4a, 0.7);
            moonLight.position.set(-12, 25, -8);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.set(2048, 2048);
            moonLight.shadow.camera.near = 0.5;
            moonLight.shadow.camera.far = 200;
            moonLight.shadow.camera.left = -50;
            moonLight.shadow.camera.right = 50;
            moonLight.shadow.camera.top = 50;
            moonLight.shadow.camera.bottom = -50;
            moonLight.shadow.bias = -0.0001;
            scene.add(moonLight);

            const rimLight = new THREE.PointLight(0x2a4a6f, 0.5, 40, 1.8);
            rimLight.position.set(8, 8, -3);
            scene.add(rimLight);

            const ambientFill = new THREE.HemisphereLight(0x0a1a1f, 0x020408, 0.4);
            scene.add(ambientFill);

            // ChÃ£o com terreno variado e mais detalhes
            const ground = createGround(80, 80, 0x0a1a12);
            scene.add(ground);

            const path = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 60, 8, 60),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1710, 
                    roughness: 0.98,
                    metalness: 0.05
                })
            );
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.01, -25);
            path.receiveShadow = true;
            scene.add(path);

            const rootsMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1f0f04, 
                roughness: 0.92,
                metalness: 0.02
            });
            for (let i = 0; i < 20; i++) {
                const root = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.2, 3.5, 6),
                    rootsMaterial
                );
                root.position.set((Math.random() - 0.5) * 10, 0.5, -10 - Math.random() * 30);
                root.rotation.z = Math.PI / 2;
                root.rotation.y = Math.random() * Math.PI;
                scene.add(root);
            }

            const trees = [];
            function criarArvoreSombria(x, z) {
                const grupo = new THREE.Group();
                const alturaTronco = 6 + Math.random() * 1.5;
                const larguraBase = 0.45 + Math.random() * 0.1;
                const larguraTopo = 0.28 + Math.random() * 0.1;
                
                const troncoMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x25150a, 
                    roughness: 0.94,
                    metalness: 0.03
                });
                const copaMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x051408, 
                    roughness: 0.85,
                    metalness: 0.01
                });

                // Tronco mais detalhado
                const tronco = new THREE.Mesh(
                    new THREE.CylinderGeometry(larguraTopo, larguraBase, alturaTronco, 12),
                    troncoMaterial
                );
                tronco.position.y = alturaTronco / 2;
                grupo.add(tronco);

                // Galhos
                const numGalhos = 3 + Math.floor(Math.random() * 3);
                for (let g = 0; g < numGalhos; g++) {
                    const alturaGalho = alturaTronco * 0.4 + (alturaTronco * 0.5 * g / numGalhos);
                    const angulo = (Math.PI * 2 * g) / numGalhos + Math.random() * 0.5;
                    const comprimento = 0.8 + Math.random() * 0.6;
                    
                    const galho = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.12, comprimento, 6),
                        troncoMaterial
                    );
                    galho.position.set(
                        Math.cos(angulo) * 0.3,
                        alturaGalho,
                        Math.sin(angulo) * 0.3
                    );
                    galho.rotation.z = Math.PI / 2;
                    galho.rotation.y = angulo;
                    grupo.add(galho);
                }

                // Copas mais naturais
                for (let i = 0; i < 4 + Math.floor(Math.random() * 2); i++) {
                    const escala = 2.4 - i * 0.4 + Math.random() * 0.3;
                    const alturaCopa = alturaTronco * 0.7 + i * 0.9;
                    const detalhes = 8 + Math.floor(Math.random() * 4);
                    
                    const copa = new THREE.Mesh(
                        new THREE.ConeGeometry(escala, 2.5 + Math.random() * 0.5, detalhes),
                        copaMaterial
                    );
                    copa.position.y = alturaCopa;
                    copa.rotation.y = Math.random() * Math.PI;
                    copa.rotation.x = (Math.random() - 0.5) * 0.2;
                    grupo.add(copa);
                }

                grupo.position.set(x, 0, z);
                grupo.traverse(obj => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                });
                trees.push(grupo);
                return grupo;
            }

            for (let i = 0; i < 45; i++) {
                const angle = (i / 45) * Math.PI * 2;
                const radius = 8 + Math.random() * 18;
                const jitter = (Math.random() - 0.5) * 4;
                const x = Math.cos(angle) * radius + jitter;
                const z = Math.sin(angle) * radius - 25 + (Math.random() - 0.5) * 8;
                scene.add(criarArvoreSombria(x, z));
            }

            const cabanaSilhouette = new THREE.Group();
            const cabanaBody = new THREE.Mesh(
                new THREE.BoxGeometry(4, 3, 4),
                new THREE.MeshStandardMaterial({ color: 0x120908, roughness: 1 })
            );
            cabanaBody.position.y = 1.5;
            cabanaSilhouette.add(cabanaBody);
            const cabanaRoof = new THREE.Mesh(
                new THREE.ConeGeometry(3.4, 2.2, 4),
                new THREE.MeshStandardMaterial({ color: 0x1b0f0b, roughness: 1 })
            );
            cabanaRoof.position.y = 3.3;
            cabanaRoof.rotation.y = Math.PI / 4;
            cabanaSilhouette.add(cabanaRoof);
            cabanaSilhouette.position.set(0, 0, -36);
            scene.add(cabanaSilhouette);

            const fogPlanes = [];
            const fogMaterial = new THREE.MeshStandardMaterial({
                color: 0x0f141f,
                transparent: true,
                opacity: 0.28,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            for (let i = 0; i < 7; i++) {
                const fogPlane = new THREE.Mesh(new THREE.PlaneGeometry(14, 6), fogMaterial.clone());
                fogPlane.position.set((Math.random() - 0.5) * 16, 1.6 + Math.random() * 1.5, -10 - i * 6);
                fogPlane.rotation.y = Math.random() * Math.PI;
                fogPlane.renderOrder = -1;
                fogPlanes.push(fogPlane);
                scene.add(fogPlane);
            }
            scene.userData.fogPlanes = fogPlanes;

            const eyesGroup = new THREE.Group();
            const eyesMeshes = [];
            for (let i = 0; i < 5; i++) {
                const holder = new THREE.Group();
                const baseZ = -12 - i * 8 - Math.random() * 6;
                const baseX = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 6);
                holder.position.set(baseX, 1.4 + Math.random() * 1.5, baseZ);

                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaa1515,
                    emissive: 0xff3030,
                    emissiveIntensity: 0.8,
                    roughness: 0.6
                });

                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), eyeMaterial);
                const rightEye = leftEye.clone();
                leftEye.position.x = -0.2;
                rightEye.position.x = 0.2;
                holder.add(leftEye, rightEye);
                eyesMeshes.push(leftEye, rightEye);
                eyesGroup.add(holder);
            }
            scene.add(eyesGroup);
            scene.userData.eyesMeshes = eyesMeshes;

            // Adicionar vaga-lumes para atmosfera mÃ­stica
            const fireflies = createFireflies(scene, 35);
            scene.userData.fireflies = fireflies;

            const cameraBase = new THREE.Vector3(0, 1.7, -6);
            const cameraLookTarget = new THREE.Vector3(0, 1.2, -22);
            scene.userData.cameraBase = cameraBase;
            scene.userData.cameraTarget = cameraLookTarget;

            setCameraPose(cameraBase, cameraLookTarget);
            scene.userData.cameraBase = cameraBase.clone();
            scene.userData.cameraLook = cameraLookTarget.clone();

            positionPlayer(0, 0, -8);
            if (gameState.player) {
                gameState.player.visible = false;
            }
            setPlayerState('alerta');
            setAmbient('floresta');

            gameState.activeUpdate = (delta) => {
                if (gameState.isCameraAnimating) return;
                scene.userData.florestaTime = (scene.userData.florestaTime || 0) + delta;
                const time = scene.userData.florestaTime;

                // Atualizar vaga-lumes
                if (scene.userData.fireflies) {
                    updateFireflies(scene.userData.fireflies, delta);
                }

                // Atualizar animaÃ§Ã£o do player
                if (gameState.player?.userData?.animate) {
                    gameState.player.userData.animate(delta);
                }

                const base = scene.userData.cameraBase;
                const target = scene.userData.cameraTarget;

                const dynamicPosition = new THREE.Vector3(
                    base.x + Math.sin(time * 0.6) * 0.12,
                    base.y + Math.sin(time * 1.4) * 0.04,
                    base.z + Math.cos(time * 0.4) * 0.07
                );
                const dynamicTarget = new THREE.Vector3(
                    target.x + Math.sin(time * 0.45) * 0.5,
                    target.y + Math.cos(time * 0.8) * 0.06,
                    target.z + Math.sin(time * 0.3) * 0.4
                );
                setCameraPose(dynamicPosition, dynamicTarget);
                if (scene.userData.fogPlanes) {
                    scene.userData.fogPlanes.forEach((plane, index) => {
                        plane.position.x += Math.sin(time * 0.3 + index) * delta * 0.8;
                        plane.position.z += delta * 2.2;
                        if (plane.position.z > 2) {
                            plane.position.z = -40 - Math.random() * 10;
                            plane.position.x = (Math.random() - 0.5) * 16;
                        }
                        plane.material.opacity = 0.18 + Math.sin(time * 0.7 + index) * 0.06;
                    });
                }

                if (scene.userData.eyesMeshes) {
                    scene.userData.eyesMeshes.forEach((eye, index) => {
                        const intensity = 0.6 + Math.abs(Math.sin(time * 3 + index * 1.7)) * 0.9;
                        eye.material.emissiveIntensity = intensity;
                    });
                }

                trees.forEach((tree, index) => {
                    tree.rotation.z = Math.sin(time * 0.2 + index) * 0.01;
                });

                scene.userData.cameraBase = dynamicPosition.clone();
                scene.userData.cameraTarget = dynamicTarget.clone();
                scene.userData.cameraLook = dynamicTarget.clone();
            };
        }

        // Criar cena da cabana
        function criarCenaCabana() {
            const scene = gameState.scene;
            clearScene();
            // GrÃ¡ficos melhorados estilo Forest Survival - ambiente mais escuro
            scene.background = new THREE.Color(0x050302);

            addCommonLights(scene, { intensity: 0.8, warm: true });

            const fog = new THREE.Fog(0x050302, 15, 40);
            scene.fog = fog;

            // IluminaÃ§Ã£o mais escura ao redor, focada na cabana
            const warmLight = new THREE.DirectionalLight(0xffd9a3, 0.4);
            warmLight.position.set(5, 10, 5);
            warmLight.castShadow = true;
            warmLight.shadow.mapSize.set(2048, 2048);
            scene.add(warmLight);

            const ambientWarm = new THREE.HemisphereLight(0xffd9a3, 0x030201, 0.3);
            scene.add(ambientWarm);
            
            // Luz adicional focada apenas na cabana para contraste
            const cabanaSpot = new THREE.SpotLight(0xffd9a3, 1.2, 25, Math.PI / 6, 0.3, 1);
            cabanaSpot.position.set(0, 8, -6);
            cabanaSpot.target.position.set(0, 0, -6);
            cabanaSpot.castShadow = true;
            scene.add(cabanaSpot);
            scene.add(cabanaSpot.target);

            // ChÃ£o maior e mais realista, similar Ã  floresta
            const ground = createGround(80, 80, 0x0b3314);
            scene.add(ground);

            const path = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 25, 10, 25),
                new THREE.MeshStandardMaterial({
                    color: 0x4a3626,
                    roughness: 0.92,
                    metalness: 0.03
                })
            );
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.02, 12);
            path.receiveShadow = true;
            scene.add(path);

            // Cabana maior e mais realista
            const cabanaGroup = new THREE.Group();
            const madeiraMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7a4a24, 
                roughness: 0.88,
                metalness: 0.04
            });
            // Cabana maior: 8x4.5x8 (antes era 6x3.6x6)
            const cabana = new THREE.Mesh(new THREE.BoxGeometry(8, 4.5, 8), madeiraMaterial);
            cabana.position.y = 2.25;
            cabana.castShadow = true;
            cabana.receiveShadow = true;
            cabanaGroup.add(cabana);

            // Telhado maior para combinar com a cabana maior
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(6.2, 3.2, 4),
                new THREE.MeshStandardMaterial({ 
                    color: 0x401d0f, 
                    roughness: 0.92,
                    metalness: 0.02
                })
            );
            roof.rotation.y = Math.PI / 4;
            roof.position.y = 5.1;
            roof.castShadow = true;
            roof.receiveShadow = true;
            cabanaGroup.add(roof);

            // Porta maior para combinar com a cabana maior
            const doorPivot = new THREE.Group();
            doorPivot.position.set(1.0, 0, 4.1);
            doorPivot.scale.set(1, 1, 1); // Garantir escala correta
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 2.8, 0.2),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2d1a0f, 
                    roughness: 0.88,
                    metalness: 0.02
                })
            );
            door.position.set(-0.9, 1.4, 0);
            door.scale.set(1, 1, 1); // Garantir escala correta
            door.castShadow = true;
            door.receiveShadow = true;
            doorPivot.add(door);
            cabanaGroup.add(doorPivot);
            scene.userData.doorPivot = doorPivot;
            scene.userData.doorMesh = door;

            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff2c6,
                emissive: 0xffd28b,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.7
            });

            // Janelas maiores
            const windowLeft = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 1.0),
                windowMaterial
            );
            windowLeft.position.set(-2.8, 1.6, 4.02);
            cabanaGroup.add(windowLeft);

            const windowRight = windowLeft.clone();
            windowRight.position.x = 2.8;
            cabanaGroup.add(windowRight);
            
            // Janela traseira
            const windowBack = new THREE.Mesh(
                new THREE.PlaneGeometry(1.2, 0.9),
                windowMaterial
            );
            windowBack.position.set(0, 1.5, -4.02);
            windowBack.rotation.y = Math.PI;
            cabanaGroup.add(windowBack);

            cabanaGroup.position.set(0, 0, -6);
            scene.add(cabanaGroup);

            const lantern = new THREE.PointLight(0xffdf9b, 2.5, 15, 2);
            lantern.position.set(0, 2.8, 3);
            cabanaGroup.add(lantern);

            const cercadoMaterial = new THREE.MeshStandardMaterial({ color: 0x5b3a1e, roughness: 0.8 });
            const cercado = new THREE.Group();
            for (let i = -1; i <= 1; i++) {
                const poste = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1.4, 8),
                    cercadoMaterial
                );
                poste.position.set(i * 3.2, 0.7, 6);
                cercado.add(poste);
            }
            const barra = new THREE.Mesh(
                new THREE.BoxGeometry(6.8, 0.15, 0.15),
                cercadoMaterial
            );
            barra.position.set(0, 1.1, 6);
            cercado.add(barra);
            scene.add(cercado);

            const acessorios = new THREE.Group();
            const barril = new THREE.Mesh(
                new THREE.CylinderGeometry(0.7, 0.7, 1.1, 16),
                new THREE.MeshStandardMaterial({ color: 0x3c2215, roughness: 0.8 })
            );
            barril.position.set(-3.5, 0.55, -3);
            acessorios.add(barril);

            const pilhaLenha = new THREE.Group();
            for (let i = 0; i < 5; i++) {
                const tronco = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 1.8, 8),
                    cercadoMaterial
                );
                tronco.position.set((i - 2) * 0.4, 0.2 + (i % 2) * 0.18, -0.4 + (Math.random() - 0.5) * 0.2);
                tronco.rotation.z = Math.PI / 2;
                pilhaLenha.add(tronco);
            }
            pilhaLenha.position.set(3.5, 0.2, -3.4);
            acessorios.add(pilhaLenha);
            scene.add(acessorios);

            // Ãrvores mais realistas e numerosas, similar Ã  floresta inicial
            const treeMaterialTrunk = new THREE.MeshStandardMaterial({ 
                color: 0x25150a, 
                roughness: 0.94,
                metalness: 0.03
            });
            const treeMaterialCrown = new THREE.MeshStandardMaterial({ 
                color: 0x051408, 
                roughness: 0.85,
                metalness: 0.01
            });
            
            function criarArvoreRealista(x, z) {
                const tree = new THREE.Group();
                const alturaTronco = 6 + Math.random() * 1.5;
                const larguraBase = 0.4 + Math.random() * 0.1;
                const larguraTopo = 0.28 + Math.random() * 0.1;
                
                // Tronco mais detalhado
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(larguraTopo, larguraBase, alturaTronco, 12),
                    treeMaterialTrunk
                );
                trunk.position.y = alturaTronco / 2;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);
                
                // Galhos
                const numGalhos = 3 + Math.floor(Math.random() * 3);
                for (let g = 0; g < numGalhos; g++) {
                    const alturaGalho = alturaTronco * 0.4 + (alturaTronco * 0.5 * g / numGalhos);
                    const angulo = (Math.PI * 2 * g) / numGalhos + Math.random() * 0.5;
                    const comprimento = 0.8 + Math.random() * 0.6;
                    
                    const galho = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.12, comprimento, 6),
                        treeMaterialTrunk
                    );
                    galho.position.set(
                        Math.cos(angulo) * 0.3,
                        alturaGalho,
                        Math.sin(angulo) * 0.3
                    );
                    galho.rotation.z = Math.PI / 2;
                    galho.rotation.y = angulo;
                    galho.castShadow = true;
                    tree.add(galho);
                }
                
                // Copas mais naturais
                for (let i = 0; i < 4 + Math.floor(Math.random() * 2); i++) {
                    const escala = 2.4 - i * 0.4 + Math.random() * 0.3;
                    const alturaCopa = alturaTronco * 0.7 + i * 0.9;
                    const detalhes = 8 + Math.floor(Math.random() * 4);
                    
                const crown = new THREE.Mesh(
                        new THREE.ConeGeometry(escala, 2.5 + Math.random() * 0.5, detalhes),
                    treeMaterialCrown
                );
                    crown.position.y = alturaCopa;
                    crown.rotation.y = Math.random() * Math.PI;
                    crown.rotation.x = (Math.random() - 0.5) * 0.2;
                    crown.castShadow = true;
                    crown.receiveShadow = true;
                tree.add(crown);
                }
                
                tree.position.set(x, 0, z);
                tree.rotation.y = Math.random() * Math.PI;
                return tree;
            }
            
            // Mais Ã¡rvores ao redor da cabana, similar Ã  floresta
            const treeRing = new THREE.Group();
            for (let i = 0; i < 35; i++) {
                const angle = (i / 35) * Math.PI * 2;
                const radius = 15 + Math.random() * 20;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius - 6;
                treeRing.add(criarArvoreRealista(x, z));
            }
            scene.add(treeRing);
            
            // Adicionar algumas Ã¡rvores menores prÃ³ximas
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 8 + Math.random() * 5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius - 6;
                const smallTree = criarArvoreRealista(x, z);
                smallTree.scale.set(0.7, 0.7, 0.7);
                scene.add(smallTree);
            }

            scene.traverse(obj => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            const cameraBase = new THREE.Vector3(0, 1.7, 6.2);
            const cameraLook = new THREE.Vector3(0, 1.4, -4);
        setCameraPose(cameraBase, cameraLook);
        scene.userData.cameraBase = cameraBase.clone();
        scene.userData.cameraLook = cameraLook.clone();
        scene.userData.cameraTarget = cameraLook.clone();

        positionPlayer(0, 0, 4, Math.PI);
        setPlayerState('idle');
        setAmbient('cabana');
        resetUpdateLoop();
    }

        function criarSalaCasaPrincipal() {
            const scene = gameState.scene;
            clearScene();

            scene.background = new THREE.Color(0x1a1410);
            addCommonLights(scene, { intensity: 1.1, warm: true });

            const ambient = new THREE.PointLight(0xffc58f, 1.4, 14, 2.2);
            ambient.position.set(0, 3.4, 0);
            scene.add(ambient);

            const floor = createGround(14, 18, 0x5a3c27);
            scene.add(floor);

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(14, 6, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x2d1b12, roughness: 0.8 })
            );
            backWall.position.set(0, 3, -9);
            scene.add(backWall);

            const sideWallLeft = new THREE.Mesh(
                new THREE.BoxGeometry(18, 6, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x2a1a11, roughness: 0.85 })
            );
            sideWallLeft.position.set(-7, 3, 0);
            sideWallLeft.rotation.y = Math.PI / 2;
            scene.add(sideWallLeft);

            const sideWallRight = sideWallLeft.clone();
            sideWallRight.position.set(7, 3, 0);
            scene.add(sideWallRight);

            const beams = new THREE.Group();
            for (let i = -3; i <= 3; i++) {
                const beam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.4, 18),
                    new THREE.MeshStandardMaterial({ color: 0x3b2518, roughness: 0.9 })
                );
                beam.position.set(i * 2, 5.5, 0);
                beams.add(beam);
            }
            scene.add(beams);

            const carpet = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 4),
                new THREE.MeshStandardMaterial({
                    color: 0x8a1f1f,
                    roughness: 0.6
                })
            );
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(0, 0.02, -1);
            scene.add(carpet);

            const table = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 0.8, 0.15, 14),
                new THREE.MeshStandardMaterial({ color: 0x372016, roughness: 0.75 })
            );
            table.position.set(0, 0.85, -1);
            scene.add(table);

            const chairMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2f1d, roughness: 0.8 });
            for (const side of [-1, 1]) {
                const chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.9, 0.5), chairMaterial);
                chair.position.set(side * 1.1, 0.45, -1.4);
                scene.add(chair);
            }

            const fireplace = new THREE.Mesh(
                new THREE.BoxGeometry(2, 3, 0.6),
                new THREE.MeshStandardMaterial({ color: 0x2d1810, roughness: 0.9 })
            );
            fireplace.position.set(-4.5, 1.6, -4.5);
            scene.add(fireplace);

            const fireLight = new THREE.PointLight(0xff8b3a, 1.6, 8, 2);
            fireLight.position.set(-4.5, 1.4, -4.5);
            scene.add(fireLight);

            const stairs = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 1.8, 4.5),
                new THREE.MeshStandardMaterial({ color: 0x3a2014, roughness: 0.85 })
            );
            stairs.position.set(4.2, 1.0, -3);
            stairs.rotation.y = Math.PI / 9;
            scene.add(stairs);

            const hallwayArch = new THREE.Mesh(
                new THREE.TorusGeometry(2.2, 0.18, 12, 24, Math.PI),
                new THREE.MeshStandardMaterial({ color: 0x28170f, roughness: 0.8 })
            );
            hallwayArch.position.set(0, 2.4, -6);
            scene.add(hallwayArch);

            const shelves = new THREE.Group();
            for (let i = -2; i <= 2; i++) {
                const shelf = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 2.2, 1.2),
                    new THREE.MeshStandardMaterial({ color: 0x2f1d13, roughness: 0.85 })
                );
                shelf.position.set(i * 1.5, 1.4, -5.5);
                shelves.add(shelf);
            }
            scene.add(shelves);

            const cameraBase = new THREE.Vector3(0.2, 1.72, 4.5);
            const cameraLook = new THREE.Vector3(0.1, 1.35, -1.8);
            setCameraPose(cameraBase, cameraLook);
            scene.userData.cameraBase = cameraBase.clone();
            scene.userData.cameraLook = cameraLook.clone();
            scene.userData.cameraTarget = cameraLook.clone();
        }

        // Criar cena de cÃ´modo
        function criarCenaComodo(config) {
            const scene = gameState.scene;
            clearScene();

            const {
                backgroundColor = 0x1a1a1a,
                floorColor = 0x444444,
                wallColor = 0xffffff,
                warmLights = false,
                accentObjects = () => {},
                cameraPosition = new THREE.Vector3(0.6, 1.7, 3.2),
                lookAt = new THREE.Vector3(0, 1.3, -0.4),
                playerPosition = new THREE.Vector3(-1.4, 0, 2.2),
                playerRotation = Math.PI / 6
            } = config;

            scene.background = new THREE.Color(backgroundColor);
            scene.fog = null;

            addCommonLights(scene, { intensity: 1.0, warm: warmLights });

            // IluminaÃ§Ã£o melhorada estilo Forest Survival
            const spot = new THREE.SpotLight(warmLights ? 0xffd9a3 : 0xcfd9ff, 1.4, 20, Math.PI / 4, 0.2, 1);
            spot.position.set(0, 5, 3);
            spot.target.position.set(0, 1, 0);
            spot.castShadow = true;
            spot.shadow.mapSize.set(2048, 2048);
            scene.add(spot);
            scene.add(spot.target);

            const fillLight = new THREE.HemisphereLight(
                warmLights ? 0xffd9a3 : 0xcfd9ff, 
                backgroundColor, 
                0.4
            );
            scene.add(fillLight);

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 10, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: floorColor, 
                    roughness: 0.92,
                    metalness: 0.03
                })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(10, 4.2, 0.2),
                new THREE.MeshStandardMaterial({ 
                    color: wallColor, 
                    roughness: 0.88,
                    metalness: 0.02
                })
            );
            backWall.position.set(0, 2.1, -5);
            backWall.receiveShadow = true;
            scene.add(backWall);

            const sideWallLeft = backWall.clone();
            sideWallLeft.rotation.y = Math.PI / 2;
            sideWallLeft.position.set(-5, 2.1, 0);
            scene.add(sideWallLeft);

            const sideWallRight = backWall.clone();
            sideWallRight.rotation.y = Math.PI / 2;
            sideWallRight.position.set(5, 2.1, 0);
            scene.add(sideWallRight);

            const ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(10, 0.2, 10),
                new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.9 })
            );
            ceiling.position.set(0, 4.2, 0);
            ceiling.receiveShadow = true;
            scene.add(ceiling);

            accentObjects(scene);

            scene.traverse(obj => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            setCameraPose(cameraPosition, lookAt);
            scene.userData.cameraBase = cameraPosition.clone();
            scene.userData.cameraLook = lookAt.clone();
            scene.userData.cameraTarget = lookAt.clone();

            positionPlayer(playerPosition.x, playerPosition.y, playerPosition.z, playerRotation);
            if (gameState.player) {
                gameState.player.visible = false;
            }
            setPlayerState('idle');
            setAmbient('cabana');
            resetUpdateLoop();
        }

        // Criar cena de fuga
        function criarCenaFuga() {
            const scene = gameState.scene;
            clearScene();

            // Fundo verde (floresta) para mais realismo
            scene.background = new THREE.Color(0x1a3a2a);
            // Nevoeiro verde suave
            scene.fog = new THREE.FogExp2(0x1a3a2a, 0.025);

            addCommonLights(scene, { intensity: 1.0, warm: false });

            // IluminaÃ§Ã£o mais clara e brilhante
            const moonLight = new THREE.DirectionalLight(0x3a5d7a, 1.2);
            moonLight.position.set(-12, 25, -8);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.set(2048, 2048);
            moonLight.shadow.camera.near = 0.5;
            moonLight.shadow.camera.far = 200;
            moonLight.shadow.camera.left = -50;
            moonLight.shadow.camera.right = 50;
            moonLight.shadow.camera.top = 50;
            moonLight.shadow.camera.bottom = -50;
            moonLight.shadow.bias = -0.0001;
            scene.add(moonLight);

            // Luz adicional de cima para vista top-down mais clara
            const topLight = new THREE.DirectionalLight(0x4a6d8a, 0.8);
            topLight.position.set(0, 30, 0);
            topLight.castShadow = true;
            topLight.shadow.mapSize.set(1024, 1024);
            topLight.shadow.camera.near = 0.5;
            topLight.shadow.camera.far = 200;
            topLight.shadow.camera.left = -50;
            topLight.shadow.camera.right = 50;
            topLight.shadow.camera.top = 50;
            topLight.shadow.camera.bottom = -50;
            scene.add(topLight);

            const rimLight = new THREE.PointLight(0x4a6a8f, 0.8, 50, 1.5);
            rimLight.position.set(8, 8, -3);
            scene.add(rimLight);

            // Luz ambiente verde (floresta)
            const ambientFill = new THREE.HemisphereLight(0x4a6a5a, 0x1a3a2a, 0.8);
            scene.add(ambientFill);
            
            // Luz verde adicional para atmosfera de floresta
            const forestLight = new THREE.DirectionalLight(0x5a8a6a, 0.4);
            forestLight.position.set(0, 15, 10);
            scene.add(forestLight);

            // ChÃ£o dinÃ¢mico que se estende conforme a distÃ¢ncia - usando funÃ§Ã£o melhorada
            const distanciaMaxima = Math.max(220, gameState.distancia_cidade + 50);
            const groundWidth = 200;
            const groundDepth = distanciaMaxima + 100;
            
            // Usar createGround para ter terreno variado e melhor qualidade - verde floresta
            const baseGround = createGround(groundWidth, groundDepth, 0x2a4a32);
            baseGround.position.z = -groundDepth / 2;
            scene.add(baseGround);
            scene.userData.baseGround = baseGround;
            scene.userData.groundDepth = groundDepth;

            // Materiais mais realistas e naturais
            const pathMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3528, 
                roughness: 0.96,
                metalness: 0.03
            });
            const rootsMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a1f14, 
                roughness: 0.92,
                metalness: 0.02
            });
            const stoneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5a5548, 
                roughness: 0.88,
                metalness: 0.06
            });
            const troncoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3d2a1a, 
                roughness: 0.94,
                metalness: 0.02
            });
            const copaMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a3a1f, 
                roughness: 0.85,
                metalness: 0.01
            });

            // Mais segmentos para floresta mais longa e contÃ­nua
            const segmentCount = 8;
            const segmentLength = 30;
            const segments = [];

            function criarArvoreSombriaFuga() {
                const grupo = new THREE.Group();
                const alturaTronco = 6.5 + Math.random() * 2.0;
                const larguraBase = 0.45 + Math.random() * 0.15;
                const larguraTopo = 0.3 + Math.random() * 0.1;

                // Tronco mais detalhado com mais segmentos
                const tronco = new THREE.Mesh(
                    new THREE.CylinderGeometry(larguraTopo, larguraBase, alturaTronco, 16),
                    troncoMaterial
                );
                tronco.position.y = alturaTronco / 2;
                tronco.castShadow = true;
                tronco.receiveShadow = true;
                grupo.add(tronco);

                // Galhos principais
                const numGalhos = 3 + Math.floor(Math.random() * 3);
                for (let g = 0; g < numGalhos; g++) {
                    const alturaGalho = alturaTronco * 0.4 + (alturaTronco * 0.5 * g / numGalhos);
                    const angulo = (Math.PI * 2 * g) / numGalhos + Math.random() * 0.5;
                    const comprimento = 0.8 + Math.random() * 0.6;
                    
                    const galho = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.12, comprimento, 6),
                        troncoMaterial
                    );
                    galho.position.set(
                        Math.cos(angulo) * 0.3,
                        alturaGalho,
                        Math.sin(angulo) * 0.3
                    );
                    galho.rotation.z = Math.PI / 2;
                    galho.rotation.y = angulo;
                    galho.castShadow = true;
                    grupo.add(galho);
                }

                // Copas mais naturais, variadas e volumosas
                const camadas = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < camadas; i++) {
                    const escala = 2.8 - i * 0.35 + Math.random() * 0.4;
                    const alturaCopa = alturaTronco * 0.65 + i * 1.0;
                    const detalhes = 10 + Math.floor(Math.random() * 6);
                    
                    const copa = new THREE.Mesh(
                        new THREE.ConeGeometry(escala, 2.8 + Math.random() * 0.7, detalhes),
                        copaMaterial
                    );
                    copa.position.y = alturaCopa;
                    copa.rotation.y = Math.random() * Math.PI;
                    copa.rotation.x = (Math.random() - 0.5) * 0.25;
                    copa.castShadow = true;
                    copa.receiveShadow = true;
                    grupo.add(copa);
                    
                    // Copas secundÃ¡rias menores para mais realismo
                    if (i > 0 && Math.random() > 0.4) {
                        const copaSec = new THREE.Mesh(
                            new THREE.ConeGeometry(escala * 0.65, 1.6, detalhes - 2),
                            copaMaterial
                        );
                        copaSec.position.set(
                            (Math.random() - 0.5) * escala * 0.9,
                            alturaCopa - 0.4,
                            (Math.random() - 0.5) * escala * 0.9
                        );
                        copaSec.rotation.y = Math.random() * Math.PI;
                        copaSec.castShadow = true;
                        grupo.add(copaSec);
                    }
                }

                grupo.userData.type = 'tree';
                return grupo;
            }

            function randomizarSegmento(segment) {
                segment.children.forEach((child) => {
                    if (child.userData?.type === 'root') {
                        const side = Math.random() > 0.5 ? 1 : -1;
                        child.position.set(side * (2.5 + Math.random() * 2), 0.35, (Math.random() - 0.5) * segmentLength);
                        child.rotation.y = Math.random() * Math.PI;
                    } else if (child.userData?.type === 'stone') {
                        child.position.set((Math.random() - 0.5) * 5, 0.12, (Math.random() - 0.5) * segmentLength);
                        const escala = 0.2 + Math.random() * 0.3;
                        child.scale.set(escala, escala, escala);
                    } else if (child.userData?.type === 'tree') {
                        // Ãrvores mais prÃ³ximas da estrada, distribuÃ­das nas laterais
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const distanceFromPath = 3.5 + Math.random() * 8; // Mais prÃ³ximo da estrada
                        child.position.set(side * distanceFromPath, 0, (Math.random() - 0.5) * segmentLength);
                        child.rotation.y = Math.random() * Math.PI;
                        // VariaÃ§Ã£o de escala para mais realismo
                        const scale = 0.8 + Math.random() * 0.4;
                        child.scale.set(scale, scale, scale);
                    } else if (child.userData?.type === 'fog') {
                        child.position.set((Math.random() - 0.5) * 14, 1.6 + Math.random() * 1.2, (Math.random() - 0.5) * 10);
                        child.material.opacity = 0.22 + Math.random() * 0.06;
                    }
                });
            }

            for (let i = 0; i < segmentCount; i++) {
                const segment = new THREE.Group();
                segment.position.z = -i * segmentLength;

                const path = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, segmentLength),
                    pathMaterial
                );
                path.rotation.x = -Math.PI / 2;
                path.position.y = 0.015;
                segment.add(path);

                for (let r = 0; r < 6; r++) {
                    const root = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.18, 3.4, 6),
                        rootsMaterial
                    );
                    root.rotation.z = Math.PI / 2;
                    root.position.y = 0.35;
                    root.userData.type = 'root';
                    root.castShadow = true;
                    root.receiveShadow = true;
                    segment.add(root);
                }

                for (let s = 0; s < 5; s++) {
                    const stone = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.25, 0),
                        stoneMaterial
                    );
                    stone.position.y = 0.12;
                    stone.userData.type = 'stone';
                    stone.castShadow = true;
                    stone.receiveShadow = true;
                    segment.add(stone);
                }

                // Mais Ã¡rvores ao lado da estrada - densidade aumentada
                for (let t = 0; t < 8; t++) {
                    const tree = criarArvoreSombriaFuga();
                    tree.userData.type = 'tree';
                    segment.add(tree);
                }

                const fogPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(14, 5),
                    new THREE.MeshStandardMaterial({
                        color: 0x2a4a3a,
                        transparent: true,
                        opacity: 0.18, // Nevoeiro verde suave
                        side: THREE.DoubleSide,
                        depthWrite: false
                    })
                );
                fogPlane.rotation.y = Math.random() * Math.PI;
                fogPlane.position.y = 1.7;
                fogPlane.userData.type = 'fog';
                segment.add(fogPlane);

                randomizarSegmento(segment);
                segments.push(segment);
                scene.add(segment);
            }

            const fogPlanes = [];
            for (let i = 0; i < 6; i++) {
                const fogPlane = new THREE.Mesh(
                    new THREE.PlaneGeometry(16, 6),
                    new THREE.MeshStandardMaterial({
                        color: 0x2a4a3a,
                        transparent: true,
                        opacity: 0.15, // Nevoeiro verde suave
                        side: THREE.DoubleSide,
                        depthWrite: false
                    })
                );
                fogPlane.position.set((Math.random() - 0.5) * 16, 1.8 + Math.random(), -8 - i * 6);
                fogPlane.rotation.y = Math.random() * Math.PI;
                fogPlane.renderOrder = -1;
                scene.add(fogPlane);
                fogPlanes.push(fogPlane);
            }
            scene.userData.fogPlanes = fogPlanes;

            const eyesGroup = new THREE.Group();
            const eyesMeshes = [];
            for (let i = 0; i < 6; i++) {
                const holder = new THREE.Group();
                holder.position.set((Math.random() > 0.5 ? 1 : -1) * (6 + Math.random() * 5), 1.5 + Math.random(), -10 - i * 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaa1515,
                    emissive: 0xff3030,
                    emissiveIntensity: 0.75,
                    roughness: 0.6
                });
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), eyeMaterial);
                const rightEye = leftEye.clone();
                leftEye.position.x = -0.18;
                rightEye.position.x = 0.18;
                holder.add(leftEye, rightEye);
                eyesMeshes.push(leftEye, rightEye);
                eyesGroup.add(holder);
            }
            scene.add(eyesGroup);
            scene.userData.eyesMeshes = eyesMeshes;

            const bodeGroup = criarModeloBode();
            bodeGroup.scale.set(1.35, 1.35, 1.35);
            bodeGroup.position.set(0, 0, gameState.proximidade_sr_bode * 0.1 - 20);
            scene.add(bodeGroup);

            // Luz mais brilhante para melhor visibilidade na vista de cima
            const bodeGlow = new THREE.PointLight(0xfcdc6b, 3.5, 25, 1.8);
            bodeGlow.position.set(0, 2.4, bodeGroup.position.z);
            scene.add(bodeGlow);
            scene.userData.bode = bodeGroup;
            scene.userData.bodeGlow = bodeGlow;

            positionPlayer(0, 0, 0, 0);
            // Vista de cima (top-down) mostrando personagem indo na direÃ§Ã£o contrÃ¡ria do Senhor Bode
            const cameraBase = new THREE.Vector3(0, 25, 0);
            const cameraLook = new THREE.Vector3(0, 0, 0);
            setCameraPose(cameraBase, cameraLook);
            scene.userData.cameraBase = cameraBase.clone();
            scene.userData.cameraLook = cameraLook.clone();
            scene.userData.cameraTarget = cameraLook.clone();
            scene.userData.environmentSegments = segments;
            scene.userData.segmentLength = segmentLength;
            setPlayerState('run');
            setAmbient('floresta');

            gameState.activeUpdate = (delta) => {
                if (gameState.isCameraAnimating) return;
                scene.userData.fugaTime = (scene.userData.fugaTime || 0) + delta;
                const tempo = scene.userData.fugaTime;

                // Estender chÃ£o dinamicamente conforme a distÃ¢ncia aumenta
                if (scene.userData.baseGround) {
                    const distanciaAtual = gameState.distancia_cidade || 0;
                    const distanciaNecessaria = distanciaAtual + 100;
                    const groundDepth = scene.userData.groundDepth || 200;
                    
                    if (distanciaNecessaria > groundDepth - 50) {
                        const novoDepth = Math.max(groundDepth, distanciaNecessaria + 50);
                        scene.userData.groundDepth = novoDepth;
                        
                        // Recriar o chÃ£o com novo tamanho usando funÃ§Ã£o melhorada
                        const oldGround = scene.userData.baseGround;
                        scene.remove(oldGround);
                        
                        const newGround = createGround(200, novoDepth, 0x0a1a12);
                        newGround.position.z = -novoDepth / 2;
                        scene.add(newGround);
                        scene.userData.baseGround = newGround;
                    }
                }

                const scrollSpeed = THREE.MathUtils.lerp(6, 12, Math.min(gameState.proximidade_sr_bode / 120, 1));
                scene.userData.environmentSegments.forEach((segment) => {
                    segment.position.z += delta * scrollSpeed;
                    if (segment.position.z > segmentLength) {
                        segment.position.z -= segmentLength * segmentCount;
                        randomizarSegmento(segment);
                    }
                });

                scene.userData.fogPlanes?.forEach((fog, index) => {
                    fog.position.x = Math.sin(tempo * 0.35 + index) * 6;
                    fog.material.opacity = 0.2 + Math.sin(tempo * 0.6 + index * 0.4) * 0.05;
                });

                scene.userData.eyesMeshes?.forEach((eye, index) => {
                    const blink = Math.sin(tempo * 3 + index);
                    eye.visible = blink > -0.85;
                    eye.material.emissiveIntensity = 0.6 + Math.max(0, blink) * 0.4;
                });

                if (scene.userData.bode) {
                    const bode = scene.userData.bode;
                    const targetZ = gameState.proximidade_sr_bode * 0.08 - 12;
                    bode.position.z += (targetZ - bode.position.z) * delta * 6;
                    bode.position.x = Math.sin(tempo * 1.5) * 1.2;
                    bode.rotation.y = Math.sin(tempo * 1.2) * 0.25;
                    if (scene.userData.bodeGlow) {
                        scene.userData.bodeGlow.position.set(bode.position.x, 2.4, bode.position.z + 0.4);
                    }
                }

                // Vista de cima: cÃ¢mera sempre olhando para baixo, seguindo o personagem
                const panicStrength = THREE.MathUtils.clamp(gameState.proximidade_sr_bode / 100, 0, 1);
                const cameraShake = (Math.random() - 0.5) * 0.08 * panicStrength;
                
                // CÃ¢mera de cima seguindo o personagem (que estÃ¡ em z=0, movendo-se para frente)
                const playerZ = -Math.min(12, gameState.distancia_cidade * 0.05);
                const dynamicPosition = new THREE.Vector3(
                    cameraShake,
                    25, // Altura fixa de cima
                    playerZ + 2 // Segue o personagem
                );

                // Olhar para o personagem (que estÃ¡ indo na direÃ§Ã£o contrÃ¡ria do bode)
                const dynamicTarget = new THREE.Vector3(
                    cameraShake * 0.5,
                    0,
                    playerZ
                );
                setCameraPose(dynamicPosition, dynamicTarget);

                scene.userData.cameraBase = dynamicPosition.clone();
                scene.userData.cameraTarget = dynamicTarget.clone();
                scene.userData.cameraLook = dynamicTarget.clone();

                scene.userData.stepTimer = (scene.userData.stepTimer || 0) + delta * scrollSpeed;
                if (scene.userData.stepTimer > 2.6) {
                    audioManager.playEffect('passo');
                    scene.userData.stepTimer = 0;
                }
            };
        }

        // AnimaÃ§Ãµes
        // FunÃ§Ãµes de UI
        function mostrarDialogo(texto) {
            document.getElementById('dialog-box').textContent = texto;
        }

        function mostrarEscolhas(opcoes) {
            const container = document.getElementById('choices-container');
            container.innerHTML = '';
            
            opcoes.forEach((opcao, index) => {
                const button = document.createElement('button');
                button.className = 'choice-button';
                button.textContent = opcao;
                button.onclick = () => escolherOpcao(index);
                container.appendChild(button);
            });
        }

        function esconderEscolhas() {
            document.getElementById('choices-container').innerHTML = '';
        }

        function atualizarInventario() {
            const container = document.getElementById('inventory');
            const itemsGrid = document.getElementById('inventory-items');
            const emptyState = document.getElementById('inventory-empty');

            if (!container || !itemsGrid || !emptyState) return;

            itemsGrid.innerHTML = '';

            if (gameState.inventario.length === 0) {
                container.classList.add('hidden');
                emptyState.style.display = 'block';
                return;
            }

            const counts = {};
            gameState.inventario.forEach(item => {
                counts[item] = (counts[item] || 0) + 1;
            });

            container.classList.remove('hidden');
            emptyState.style.display = 'none';

            Object.entries(counts).forEach(([item, count]) => {
                const def = ITEM_DEFS[item] || {
                    icon: 'ðŸ“¦',
                    name: item,
                    detail: '',
                    color: '#ffffff'
                };

                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.style.borderColor = `${def.color}80`;
                slot.style.boxShadow = `0 0 12px ${def.color}22`;

                const icon = document.createElement('div');
                icon.className = 'inventory-icon';
                icon.textContent = def.icon;

                const labels = document.createElement('div');
                labels.className = 'inventory-labels';

                const name = document.createElement('div');
                name.className = 'inventory-name';
                name.textContent = def.name;

                labels.appendChild(name);

                if (def.detail) {
                    const detail = document.createElement('div');
                    detail.className = 'inventory-details';
                    detail.textContent = def.detail;
                    labels.appendChild(detail);
                }

                slot.appendChild(icon);
                slot.appendChild(labels);

                if (count > 1) {
                    const countBadge = document.createElement('div');
                    countBadge.className = 'inventory-count';
                    countBadge.textContent = `x${count}`;
                    slot.appendChild(countBadge);
                }

                itemsGrid.appendChild(slot);
            });
        }

        function atualizarStats() {
            const distanceValue = document.getElementById('distance-value');
            const proximityValue = document.getElementById('proximity-value');
            const distanceLabel = document.getElementById('distance-label');
            const proximityLabel = document.getElementById('proximity-label');
            const statsContainer = document.getElementById('stats');
            const hungerStat = document.getElementById('hunger-stat');
            const hungerFill = document.getElementById('hunger-fill');
            const hungerValue = document.getElementById('hunger-value');

            // Na fuga, mostrar distÃ¢ncia atÃ© a cidade (220 - distancia_cidade)
            const distanciaDisplay = gameState.cena_atual === 'fuga' 
                ? Math.max(0, Math.round(220 - gameState.distancia_cidade))
                : Math.max(0, Math.round(gameState.distancia_cidade));
            const proximidadeDisplay = Math.max(0, Math.round(gameState.proximidade_sr_bode));

            if (distanceValue) distanceValue.textContent = distanciaDisplay;
            if (proximityValue) proximityValue.textContent = proximidadeDisplay;

            if (distanceLabel) {
                distanceLabel.textContent = gameState.cena_atual === 'fuga' ? 'DistÃ¢ncia atÃ© a cidade:' : 'DistÃ¢ncia:';
            }
            if (proximityLabel) {
                proximityLabel.textContent = gameState.cena_atual === 'fuga' ? 'DistÃ¢ncia do Sr Bode:' : 'Proximidade Bode:';
            }

            const hungerPercent = Math.max(0, Math.min(100, Math.round(gameState.fome)));
            if (hungerFill) {
                hungerFill.style.width = `${hungerPercent}%`;
            }
            if (hungerValue) {
                hungerValue.textContent = `${hungerPercent}%`;
            }

            if (gameState.cena_atual === 'fuga') {
                statsContainer?.classList.remove('hidden');
                hungerStat?.classList.remove('hidden');
            } else {
                statsContainer?.classList.add('hidden');
                hungerStat?.classList.add('hidden');
            }
        }

        let escolhaAtual = null;

        function escolherOpcao(index) {
            escolhaAtual = index;
        }

        function aguardarEscolha() {
            return new Promise((resolve) => {
                const checkEscolha = setInterval(() => {
                    if (escolhaAtual !== null) {
                        const escolha = escolhaAtual;
                        escolhaAtual = null;
                        clearInterval(checkEscolha);
                        resolve(escolha);
                    }
                }, 100);
            });
        }

        // FunÃ§Ãµes do jogo
        async function floresta() {
            gameState.cena_atual = 'floresta';
            criarCenaFloresta();
            mostrarDialogo('VocÃª acorda no meio da floresta.\nEntre as Ã¡rvores, hÃ¡ uma fumaÃ§a subindo ao longe...');
            mostrarEscolhas(['1 - Ir em direÃ§Ã£o Ã  fumaÃ§a', '2 - Ir na direÃ§Ã£o contrÃ¡ria']);
            
            const escolha = await aguardarEscolha();
            esconderEscolhas();
            
            if (escolha === 1) {
                mostrarDialogo('VocÃª tenta se afastar da fumaÃ§a, mas sente algo se aproximando...');
                await animateFirstPersonMove([
                    {
                        position: new THREE.Vector3(-1.4, 1.65, -7.5),
                        lookAt: new THREE.Vector3(-1.9, 1.2, -12)
                    },
                    {
                        position: new THREE.Vector3(-2.7, 1.48, -10.6),
                        lookAt: new THREE.Vector3(-2.4, 1.1, -14)
                    }
                ], { duration: 2.8, easing: 'easeInOutCubic' });
                setPlayerState('alerta');
                audioManager.playEffect('perigo');
                setAmbient(null);
                mostrarDialogo('Um urso aparece e vocÃª Ã© morto!');
                await new Promise(resolve => setTimeout(resolve, 3000));
                return false;
            } else {
                mostrarDialogo('VocÃª avanÃ§a cautelosamente, seguindo a trilha de fumaÃ§a pela floresta.');
                await animateFirstPersonMove([
                    {
                        position: new THREE.Vector3(0.2, 1.7, -10),
                        lookAt: new THREE.Vector3(0.2, 1.25, -16)
                    },
                    {
                        position: new THREE.Vector3(0, 1.65, -18),
                        lookAt: new THREE.Vector3(0, 1.2, -26)
                    },
                    {
                        position: new THREE.Vector3(0, 1.6, -26),
                        lookAt: new THREE.Vector3(0, 1.15, -34)
                    }
                ], { duration: 4.6, easing: 'easeInOutCubic' });
                audioManager.playEffect('passo');
                mostrarDialogo('A cabana surge diante de vocÃª, envolta pela nÃ©voa sinistra.');
                await new Promise(resolve => setTimeout(resolve, 2000));
                return true;
            }
        }

        async function cabana() {
            gameState.cena_atual = 'cabana';
            criarCenaCabana();
            const scene = gameState.scene;
            const bode = criarModeloBode();
            // Reduzir escala para caber na porta maior (1.8x2.8) - altura porta Ã© 2.8
            bode.scale.set(0.9, 0.9, 0.9);
            // PosiÃ§Ã£o ajustada: porta estÃ¡ em (1.0, 0, -1.9) na cena (cabana em z=-6, porta em z=4.1 relativo)
            bode.position.set(1.0, 0, -0.5); // PosiÃ§Ã£o inicial mais distante da porta
            const bodeLight = new THREE.PointLight(0xffd15a, 1.6, 8, 2.2);
            bodeLight.position.set(1.0, 2.2, -0.5);
            scene.add(bode);
            scene.add(bodeLight);
            const doorPivot = scene.userData?.doorPivot;
            if (doorPivot) {
                doorPivot.rotation.y = 0;
                await animateDoor(doorPivot, 0, -Math.PI / 1.6, 1.8);
            }
            // Mover para posiÃ§Ã£o na porta (porta estÃ¡ em x=1.0, z=-1.9)
            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(1.0, 0, -1.9), 2.4);
            bodeLight.position.set(1.0, 2.2, -1.9);

            const { base, look } = getSceneCameraBase();
            mostrarDialogo('VocÃª se aproxima da porta; batidas ecoam e o Senhor Bode atende.\n"Oi, vocÃª estÃ¡ perdido?"\n\nEle permite que vocÃª fique, mas com 3 regras:\n1 - NÃ£o saia do seu quarto Ã  noite\n2 - NÃ£o desrespeite o Senhor Bode\n3 - NÃ£o fale com o Senhor Lobo');
            await animateFirstPersonMove([
                {
                    position: base.clone().add(new THREE.Vector3(0, 0, -1.8)),
                    lookAt: look.clone().add(new THREE.Vector3(0, -0.05, -2))
                },
                {
                    position: base.clone(),
                    lookAt: look.clone()
                }
            ], { duration: 2.6, easing: 'easeInOutCubic' });
            mostrarEscolhas(['Continuar']);
            await aguardarEscolha();
            await playActionNod(0.4);
            esconderEscolhas();
            if (doorPivot) {
                await animateDoor(doorPivot, doorPivot.rotation.y, 0, 1.5);
            }
            scene.remove(bode);
            scene.remove(bodeLight);
            mostrarDialogo('Agora vocÃª pode explorar a casa antes da fuga.');
            atualizarInventario();
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        async function cozinha() {
            gameState.cena_atual = 'cozinha';
            criarCenaComodo({
                backgroundColor: 0x1c1f2f,
                floorColor: 0x545454,
                wallColor: 0xd8d4c8,
                warmLights: true,
                accentObjects: (scene) => {
                    const bancada = new THREE.Mesh(
                        new THREE.BoxGeometry(5, 0.6, 1.6),
                        new THREE.MeshStandardMaterial({ color: 0x4d3a2f, roughness: 0.7 })
                    );
                    bancada.position.set(0, 0.9, -1.2);
                    scene.add(bancada);

                    const mesa = new THREE.Mesh(
                        new THREE.BoxGeometry(2.4, 0.15, 1.4),
                        new THREE.MeshStandardMaterial({ color: 0x6a4b30, roughness: 0.6 })
                    );
                    mesa.position.set(1.2, 0.85, 1.5);
                    scene.add(mesa);

                    const cesta = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.5, 0.3, 16, 1, false),
                        new THREE.MeshStandardMaterial({ color: 0xc4782a, roughness: 0.6 })
                    );
                    cesta.position.set(1.2, 0.95, 1.1);
                    scene.add(cesta);

                    const comidaMaterial = new THREE.MeshStandardMaterial({ color: 0xffd66b, roughness: 0.5 });
                    for (let i = 0; i < 4; i++) {
                        const fruta = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), comidaMaterial);
                        fruta.position.set(1.2 + (Math.random() - 0.5) * 0.4, 1.05 + Math.random() * 0.1, 1.1 + (Math.random() - 0.5) * 0.4);
                        scene.add(fruta);
                    }

                    const panela = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 0.25, 24),
                        new THREE.MeshStandardMaterial({ color: 0x2a3035, roughness: 0.4 })
                    );
                    panela.position.set(-1.5, 0.95, -1.1);
                    scene.add(panela);

                    const vaporMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        opacity: 0.25,
                        transparent: true
                    });
                    const vaporGroup = new THREE.Group();
                    for (let i = 0; i < 3; i++) {
                        const vapor = new THREE.Mesh(new THREE.SphereGeometry(0.25 - i * 0.05, 12, 12), vaporMaterial);
                        vapor.position.set((Math.random() - 0.5) * 0.3, 0.2 + i * 0.4, (Math.random() - 0.5) * 0.3);
                        vaporGroup.add(vapor);
                    }
                    vaporGroup.position.set(-1.5, 1.1, -1.1);
                    scene.add(vaporGroup);

                    scene.userData.vaporGroup = vaporGroup;
                },
                playerPosition: new THREE.Vector3(-1.2, 0, 2.4),
                playerRotation: Math.PI / 3
            });
            gameState.activeUpdate = (delta) => {
                const vaporGroup = gameState.scene?.userData?.vaporGroup;
                if (!vaporGroup) return;
                vaporGroup.children.forEach((puff, idx) => {
                    puff.position.y += Math.sin((performance.now() / 1000 + idx) * 2) * 0.0008;
                    puff.position.x += Math.sin((performance.now() / 1000 + idx) * 1.5) * 0.0005;
                });
            };
            const cozinhaCamera = getSceneCameraBase();
            mostrarDialogo('VocÃª entra na cozinha. O aroma de comida recÃ©m-preparada invade o ar.');
            await animateFirstPersonMove([
                {
                    position: cozinhaCamera.base.clone().add(new THREE.Vector3(0.12, 0.03, -0.9)),
                    lookAt: cozinhaCamera.look.clone().add(new THREE.Vector3(0.1, -0.05, -0.6))
                },
                {
                    position: cozinhaCamera.base.clone(),
                    lookAt: cozinhaCamera.look.clone()
                }
            ], { duration: 1.8 });
            mostrarEscolhas(['1 - Pegar comida', '2 - Ignorar']);
            atualizarInventario();
            
            const escolha = await aguardarEscolha();
            await playActionNod(0.4);
            esconderEscolhas();
            
            if (escolha === 0) {
                gameState.inventario.push('Comida');
                audioManager.playEffect('coleta');
                mostrarDialogo('VocÃª pega porÃ§Ãµes da cesta: energia garantida para a fuga!');
            } else {
                mostrarDialogo('VocÃª decide nÃ£o tocar em nada por enquanto.');
            }
            atualizarInventario();
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        async function quarto_sr_bode() {
            gameState.cena_atual = 'quarto_bode';
            criarCenaComodo({
                backgroundColor: 0x1a0202,
                floorColor: 0x330606,
                wallColor: 0x4b0909,
                warmLights: false,
                accentObjects: (scene) => {
                    const cama = new THREE.Mesh(
                        new THREE.BoxGeometry(3.4, 0.6, 2),
                        new THREE.MeshStandardMaterial({ color: 0x2d0505, roughness: 0.8 })
                    );
                    cama.position.set(0.5, 0.5, -1);
                    scene.add(cama);

                    const colchao = new THREE.Mesh(
                        new THREE.BoxGeometry(3.2, 0.4, 1.8),
                        new THREE.MeshStandardMaterial({ color: 0x4d1a1a, roughness: 0.6 })
                    );
                    colchao.position.set(0.5, 0.9, -1);
                    scene.add(colchao);

                    const ganchos = new THREE.Group();
                    for (let i = -1; i <= 1; i++) {
                        const suporte = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, 1, 8),
                            new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 })
                        );
                        suporte.position.set(i * 1.2, 1.8, -4.8);
                        ganchos.add(suporte);

                        const gancho = new THREE.Mesh(
                            new THREE.TorusGeometry(0.25, 0.03, 8, 16, Math.PI),
                            new THREE.MeshStandardMaterial({ color: 0xb3a28a, roughness: 0.4 })
                        );
                        gancho.position.set(i * 1.2, 1.3, -4.6);
                        gancho.rotation.z = Math.PI / 2;
                        ganchos.add(gancho);
                    }
                    scene.add(ganchos);

                    const ossadas = new THREE.Group();
                    const ossoMaterial = new THREE.MeshStandardMaterial({ color: 0xebe1d5, roughness: 0.7 });
                    for (let i = 0; i < 6; i++) {
                        const osso = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.08, 0.08, 0.8, 12),
                            ossoMaterial
                        );
                        osso.position.set(-1.8 + Math.random() * 3.6, 0.2 + Math.random() * 0.4, Math.random() * 3 - 2);
                        osso.rotation.z = Math.random() * Math.PI;
                        ossadas.add(osso);
                    }
                    scene.add(ossadas);

                    const luzSangue = new THREE.PointLight(0xff3030, 1.4, 12, 1.5);
                    luzSangue.position.set(0.5, 2.5, -1);
                    scene.add(luzSangue);
                },
                playerPosition: new THREE.Vector3(-1.8, 0, 2.5),
                playerRotation: Math.PI / 4
            });
            const quartoCamera = getSceneCameraBase();
            mostrarDialogo('VocÃª entra no quarto do Senhor Bode. Ganchos com restos mortais pendem das paredes...');
            await animateFirstPersonMove([
                {
                    position: quartoCamera.base.clone().add(new THREE.Vector3(-0.1, 0.04, -0.9)),
                    lookAt: quartoCamera.look.clone().add(new THREE.Vector3(-0.1, -0.02, -1.1))
                },
                {
                    position: quartoCamera.base.clone(),
                    lookAt: quartoCamera.look.clone()
                }
            ], { duration: 1.9 });
            gameState.inventario.push('Medo extremo');
            audioManager.playEffect('perigo');
            setPlayerState('alerta');
            atualizarInventario();
            mostrarEscolhas(['Continuar']);
            await aguardarEscolha();
            await playActionNod(0.45);
            esconderEscolhas();
        }

        async function biblioteca() {
            gameState.cena_atual = 'biblioteca';
            criarCenaComodo({
                backgroundColor: 0x22160c,
                floorColor: 0x704a2c,
                wallColor: 0x3d2a1b,
                warmLights: true,
                accentObjects: (scene) => {
                    const estanteMaterial = new THREE.MeshStandardMaterial({ color: 0x4f2f1b, roughness: 0.7 });
                    for (let i = -3; i <= 3; i += 2.5) {
                        const estante = new THREE.Mesh(
                            new THREE.BoxGeometry(1.8, 3, 0.6),
                            estanteMaterial
                        );
                        estante.position.set(i, 1.6, -3.2);
                        scene.add(estante);

                        for (let j = 0; j < 3; j++) {
                            const livros = new THREE.Mesh(
                                new THREE.BoxGeometry(1.4, 0.9, 0.4),
                                new THREE.MeshStandardMaterial({ color: 0x8a5b2a + j * 0x080808, roughness: 0.6 })
                            );
                            livros.position.set(i, 0.6 + j * 0.9, -2.9);
                            scene.add(livros);
                        }
                    }

                    const mesaMapas = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.2, 1.2, 0.15, 16),
                        new THREE.MeshStandardMaterial({ color: 0x5b3a1c, roughness: 0.7 })
                    );
                    mesaMapas.position.set(0, 0.8, 0);
                    scene.add(mesaMapas);

                    const mapa = new THREE.Mesh(
                        new THREE.CircleGeometry(1, 24),
                        new THREE.MeshStandardMaterial({ color: 0xf2d49b, roughness: 0.6 })
                    );
                    mapa.rotation.x = -Math.PI / 2;
                    mapa.position.set(0, 0.89, 0);
                    scene.add(mapa);

                    const lamp = new THREE.PointLight(0xffe4a0, 1.6, 10, 1.5);
                    lamp.position.set(0, 2.6, 0);
                    scene.add(lamp);
                },
                playerPosition: new THREE.Vector3(-2.2, 0, 2.4),
                playerRotation: Math.PI / 3
            });
            const bibliotecaCamera = getSceneCameraBase();
            mostrarDialogo('VocÃª entra na biblioteca e encontra mapas e anotaÃ§Ãµes espalhados por todos os lados.');
            await animateFirstPersonMove([
                {
                    position: bibliotecaCamera.base.clone().add(new THREE.Vector3(0.08, 0.03, -0.8)),
                    lookAt: bibliotecaCamera.look.clone().add(new THREE.Vector3(0.1, -0.02, -0.6))
                },
                {
                    position: bibliotecaCamera.base.clone(),
                    lookAt: bibliotecaCamera.look.clone()
                }
            ], { duration: 1.7 });
            mostrarEscolhas(['1 - Ler mapas', '2 - Ignorar']);
            atualizarInventario();
            
            const escolha = await aguardarEscolha();
            await playActionNod(0.4);
            esconderEscolhas();
            
            if (escolha === 0) {
                gameState.inventario.push('Mapa');
                audioManager.playEffect('coleta');
                mostrarDialogo('VocÃª decifra atalhos escondidos na floresta e memorizÃ¡-los.');
            } else {
                mostrarDialogo('VocÃª prefere nÃ£o perder tempo com as anotaÃ§Ãµes.');
            }
            atualizarInventario();
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        async function sotao() {
            gameState.cena_atual = 'sotao';
            criarCenaComodo({
                backgroundColor: 0x2a2a2a,
                floorColor: 0x5f5f5f,
                wallColor: 0x3b3b3b,
                warmLights: false,
                accentObjects: (scene) => {
                    const vigas = new THREE.Group();
                    for (let i = -4; i <= 4; i += 2) {
                        const viga = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 8),
                            new THREE.MeshStandardMaterial({ color: 0x4a4640, roughness: 0.9 })
                        );
                        viga.position.set(i, 3.8, 0);
                        scene.add(viga);
                    }
                    scene.add(vigas);

                    const caixas = new THREE.Group();
                    for (let i = 0; i < 4; i++) {
                        const caixa = new THREE.Mesh(
                            new THREE.BoxGeometry(1.2, 0.8, 1.2),
                            new THREE.MeshStandardMaterial({ color: 0x8d6e53, roughness: 0.8 })
                        );
                        caixa.position.set(-2 + i * 1.3, 0.5, -1 + (i % 2) * 1.5);
                        caixas.add(caixa);
                    }
                    scene.add(caixas);

                    const feixeLuz = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0, 3.2, 6, 1, true),
                        new THREE.MeshStandardMaterial({
                            color: 0xcfdfff,
                            emissive: 0xbad4ff,
                            emissiveIntensity: 0.5,
                            transparent: true,
                            opacity: 0.35
                        })
                    );
                    feixeLuz.position.set(2, 2, 0.5);
                    feixeLuz.rotation.x = Math.PI;
                    scene.add(feixeLuz);
                    scene.userData.feixeLuz = feixeLuz;

                    const teiaMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.4
                    });
                    const teia = new THREE.Mesh(new THREE.CircleGeometry(0.7, 12), teiaMaterial);
                    teia.position.set(-3.4, 3.5, -4.8);
                    scene.add(teia);
                    scene.userData.teia = teia;
                },
                playerPosition: new THREE.Vector3(-2.2, 0, 2.8),
                playerRotation: Math.PI / 3
            });
            gameState.activeUpdate = (delta) => {
                const teia = gameState.scene?.userData?.teia;
                const feixe = gameState.scene?.userData?.feixeLuz;
                if (teia) {
                    teia.rotation.z += delta * 0.1;
                }
                if (feixe) {
                    feixe.material.opacity = 0.25 + Math.sin(performance.now() / 1200) * 0.1;
                }
            };
            const sotaoCamera = getSceneCameraBase();
            mostrarDialogo('VocÃª sobe ao sÃ³tÃ£o. Caixas antigas e feixes de luz revelam esconderijos curiosos.');
            await animateFirstPersonMove([
                {
                    position: sotaoCamera.base.clone().add(new THREE.Vector3(0.15, 0.02, -0.7)),
                    lookAt: sotaoCamera.look.clone().add(new THREE.Vector3(0.1, -0.05, -0.6))
                },
                {
                    position: sotaoCamera.base.clone(),
                    lookAt: sotaoCamera.look.clone()
                }
            ], { duration: 1.8 });
            mostrarEscolhas(['1 - Pegar um item', '2 - Ignorar']);
            atualizarInventario();
            
            const escolha = await aguardarEscolha();
            await playActionNod(0.4);
            esconderEscolhas();
            
            if (escolha === 0) {
                const itens = ['Escopeta', 'SabÃ£o Macaco', 'Comida'];
                const item = itens[Math.floor(Math.random() * itens.length)];
                gameState.inventario.push(item);
                audioManager.playEffect('coleta');
                mostrarDialogo(`VocÃª encontra um baÃº e pega ${item}!`);
            } else {
                mostrarDialogo('VocÃª desce sem levar nada consigo.');
            }
            atualizarInventario();
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        async function banheiro() {
            gameState.cena_atual = 'banheiro';
            criarCenaComodo({
                backgroundColor: 0xdde5f7,
                floorColor: 0xaab7d1,
                wallColor: 0xe8f0ff,
                warmLights: false,
                accentObjects: (scene) => {
                    const azulejos = new THREE.Mesh(
                        new THREE.PlaneGeometry(10, 4),
                        new THREE.MeshStandardMaterial({ color: 0xd3def0, roughness: 0.6 })
                    );
                    azulejos.position.set(0, 2, -4.95);
                    scene.add(azulejos);

                    const banheira = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.6, 1.6, 0.7, 24, 1, true),
                        new THREE.MeshStandardMaterial({ color: 0xf9fbff, roughness: 0.2 })
                    );
                    banheira.position.set(-1.5, 0.5, -0.8);
                    scene.add(banheira);

                    const agua = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.55, 1.55, 0.6, 24),
                        new THREE.MeshStandardMaterial({
                            color: 0x9ed6ff,
                            transparent: true,
                            opacity: 0.7,
                            roughness: 0.1,
                            metalness: 0.2
                        })
                    );
                    agua.position.set(-1.5, 0.8, -0.8);
                    scene.add(agua);

                    const pia = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 0.4, 0.6),
                        new THREE.MeshStandardMaterial({ color: 0xf1f5ff, roughness: 0.3 })
                    );
                    pia.position.set(2, 1, 0.2);
                    scene.add(pia);

                    const espelho = new THREE.Mesh(
                        new THREE.PlaneGeometry(1.4, 1.2),
                        new THREE.MeshStandardMaterial({
                            color: 0xd0e7ff,
                            emissive: 0xaccff2,
                            emissiveIntensity: 0.5
                        })
                    );
                    espelho.position.set(2, 2, -0.1);
                    scene.add(espelho);

                    const vapor = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, 1.8),
                        new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 })
                    );
                    vapor.position.set(-1.5, 1.8, -0.7);
                    vapor.rotation.y = Math.PI / 12;
                    scene.add(vapor);
                    scene.userData.vaporPainel = vapor;

                    const luzFria = new THREE.PointLight(0xbad4ff, 1.2, 10, 1.5);
                    luzFria.position.set(0, 2.8, 1.2);
                    scene.add(luzFria);
                },
                playerPosition: new THREE.Vector3(1.8, 0, 2.4),
                playerRotation: -Math.PI / 3
            });
            gameState.activeUpdate = (delta) => {
                const vapor = gameState.scene?.userData?.vaporPainel;
                if (vapor) {
                    vapor.material.opacity = 0.18 + Math.sin(performance.now() / 900) * 0.04;
                }
            };
            const banheiroCamera = getSceneCameraBase();
            mostrarDialogo('VocÃª entra no banheiro, toma um banho rÃ¡pido e renova as forÃ§as.');
            await animateFirstPersonMove([
                {
                    position: banheiroCamera.base.clone().add(new THREE.Vector3(-0.1, 0.02, -0.7)),
                    lookAt: banheiroCamera.look.clone().add(new THREE.Vector3(-0.1, -0.02, -0.6))
                },
                {
                    position: banheiroCamera.base.clone(),
                    lookAt: banheiroCamera.look.clone()
                }
            ], { duration: 1.6 });
            atualizarInventario();
            mostrarEscolhas(['Continuar']);
            await aguardarEscolha();
            await playActionNod(0.35);
            esconderEscolhas();
        }

        async function aguardar_bode_mercado() {
            gameState.cena_atual = 'aguardar_bode';
            gameState.bodeNoMercado = false;
            criarCenaCabana();
            const scene = gameState.scene;
            const bode = criarModeloBode();
            bode.scale.set(1.3, 1.3, 1.3);
            bode.position.set(0, 0, -3.2);
            const bodeLight = new THREE.PointLight(0xffd15a, 1.4, 10, 1.8);
            bodeLight.position.set(0, 2.1, -2.8);
            scene.add(bode);
            scene.add(bodeLight);

            mostrarDialogo('O sol comeÃ§a a cair. O Senhor Bode se prepara para ir ao mercado da tarde.');
            await new Promise((resolve) => setTimeout(resolve, 1600));
            audioManager.playEffect('passo');

            const startPos = bode.position.clone();
            const endPos = new THREE.Vector3(0, 0, -14);
            await animateModelMove(bode, startPos, endPos, 3.2);

            scene.remove(bode);
            scene.remove(bodeLight);
            mostrarDialogo('O Senhor Bode desaparece na nÃ©voa do bosque. A casa estÃ¡ silenciosa para explorar.');
            gameState.bodeNoMercado = true;
            gameState.comodosExplorados = 0;
            await new Promise((resolve) => setTimeout(resolve, 2000));
        }

        async function bodeRetornaCasa() {
            gameState.cena_atual = 'retorno_bode';
            criarCenaCabana();
            const scene = gameState.scene;

            const bode = criarModeloBode();
            bode.scale.set(1.3, 1.3, 1.3);
            bode.position.set(0, 0, -12);
            const bodeLight = new THREE.PointLight(0xffd15a, 1.2, 9, 1.6);
            bodeLight.position.set(0, 2.1, -9);
            scene.add(bode);
            scene.add(bodeLight);

            mostrarDialogo('Passos ecoam pela floresta... o Senhor Bode estÃ¡ retornando do mercado!');
            audioManager.playEffect('passo');
            await new Promise(resolve => setTimeout(resolve, 1400));

            await animateModelMove(bode, bode.position.clone(), new THREE.Vector3(0, 0, -3.4), 2.6);
            mostrarDialogo('VocÃª se esconde Ã s pressas enquanto o Senhor Bode entra em casa.');
            await new Promise(resolve => setTimeout(resolve, 1600));

            scene.remove(bode);
            scene.remove(bodeLight);
            gameState.bodeNoMercado = false;
            
            // Nova cena: Festa na casa do Senhor Bode (sÃ³ acontece uma vez)
            if (!gameState.festaAconteceu) {
                await festaNaCasa();
                gameState.festaAconteceu = true;
            }
        }

        async function festaNaCasa() {
            gameState.cena_atual = 'festa';
            criarSalaCasaPrincipal();
            const scene = gameState.scene;

            // Adicionar decoraÃ§Ã£o de festa
            const festaLights = [];
            for (let i = -3; i <= 3; i += 2) {
                const light = new THREE.PointLight(0xffd700, 1.5, 8, 1.5);
                light.position.set(i * 1.5, 3.5, -2);
                scene.add(light);
                festaLights.push(light);
            }

            // Senhor Bode (anfitriÃ£o)
            const bode = criarModeloBode();
            bode.scale.set(1.2, 1.2, 1.2);
            bode.position.set(0, 0, -2);
            scene.add(bode);

            // Convidados
            const srGanso = criarModeloGanso();
            srGanso.scale.set(0.8, 0.8, 0.8);
            srGanso.position.set(-2.5, 0, -1.5);
            scene.add(srGanso);

            const sraGanso = criarModeloGansoFeminino();
            sraGanso.scale.set(0.8, 0.8, 0.8);
            sraGanso.position.set(-2.5, 0, -2.5);
            scene.add(sraGanso);

            const srLeao = criarModeloLeao();
            srLeao.scale.set(0.9, 0.9, 0.9);
            srLeao.position.set(2.5, 0, -1.5);
            scene.add(srLeao);

            const sraCobra = criarModeloCobra();
            sraCobra.scale.set(1.2, 1.2, 1.2);
            sraCobra.position.set(2.5, 0.3, -2.5);
            sraCobra.rotation.y = Math.PI / 4;
            scene.add(sraCobra);

            mostrarDialogo('O Senhor Bode anuncia: "Hoje temos uma festa especial! Todos os convidados chegaram."');
            await new Promise(resolve => setTimeout(resolve, 2500));

            mostrarDialogo('VocÃª vÃª os convidados: Sr Ganso, Sra Ganso, Sr LeÃ£o e Sra Cobra.');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('O Senhor Bode se vira para vocÃª: "Preciso de ajuda para servir os convidados. VocÃª pode ajudar?"');
            mostrarEscolhas(['1 - Aceitar ajudar', '2 - Recusar']);
            atualizarInventario();

            const escolha = await aguardarEscolha();
            esconderEscolhas();

            if (escolha === 0) {
                mostrarDialogo('VocÃª aceita ajudar a servir na festa.');
                await new Promise(resolve => setTimeout(resolve, 1500));
                await servirNaFesta(scene, bode, srGanso, sraGanso, srLeao, sraCobra);
            } else {
                mostrarDialogo('VocÃª recusa, mas o Senhor Bode insiste: "Ã‰ importante para mim."');
                await new Promise(resolve => setTimeout(resolve, 2000));
                await servirNaFesta(scene, bode, srGanso, sraGanso, srLeao, sraCobra);
            }

            // Limpar cena
            festaLights.forEach(light => scene.remove(light));
            scene.remove(bode);
            scene.remove(srGanso);
            scene.remove(sraGanso);
            scene.remove(srLeao);
            scene.remove(sraCobra);
        }

        async function servirNaFesta(scene, bode, srGanso, sraGanso, srLeao, sraCobra) {
            mostrarDialogo('VocÃª comeÃ§a a servir comida e bebida para os convidados...');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('VocÃª serve o Sr Ganso e a Sra Ganso. Eles agradecem educadamente.');
            await animateModelMove(srGanso, srGanso.position.clone(), new THREE.Vector3(-2.5, 0, -1.2), 1.0);
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('VocÃª serve a Sra Cobra. Ela sibila agradecendo.');
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('VocÃª se aproxima do Sr LeÃ£o para servi-lo...');
            await animateModelMove(srLeao, srLeao.position.clone(), new THREE.Vector3(2.2, 0, -1.2), 1.0);
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('O Sr LeÃ£o olha para vocÃª com interesse: "Obrigado. VocÃª poderia me ajudar com algo no sÃ³tÃ£o?"');
            mostrarEscolhas(['1 - Aceitar ir ao sÃ³tÃ£o', '2 - Recusar']);
            atualizarInventario();

            const escolha = await aguardarEscolha();
            esconderEscolhas();

            if (escolha === 0) {
                mostrarDialogo('VocÃª aceita ajudar o Sr LeÃ£o no sÃ³tÃ£o.');
                await new Promise(resolve => setTimeout(resolve, 1500));
                await assedioNoSotao(scene, srLeao);
            } else {
                mostrarDialogo('VocÃª recusa, mas o Sr LeÃ£o insiste: "Ã‰ muito importante. Por favor."');
                await new Promise(resolve => setTimeout(resolve, 2000));
                mostrarDialogo('VocÃª relutantemente aceita.');
                await new Promise(resolve => setTimeout(resolve, 1500));
                await assedioNoSotao(scene, srLeao);
            }
        }

        async function assedioNoSotao(scene, srLeao) {
            gameState.cena_atual = 'assedio_sotao';
            criarSalaCasaPrincipal();
            
            // Recriar sÃ³tÃ£o
            await sotao();
            
            const sceneSotao = gameState.scene;
            
            // Adicionar Sr LeÃ£o no sÃ³tÃ£o
            const leaoSotao = criarModeloLeao();
            leaoSotao.scale.set(1.1, 1.1, 1.1);
            leaoSotao.position.set(-1.5, 0, 1.5);
            sceneSotao.add(leaoSotao);

            mostrarDialogo('VocÃª sobe ao sÃ³tÃ£o com o Sr LeÃ£o...');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('O Sr LeÃ£o fecha a porta do sÃ³tÃ£o atrÃ¡s de vocÃª.');
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('Sr LeÃ£o: "VocÃª Ã© muito bonito... NÃ£o hÃ¡ ninguÃ©m aqui para nos ouvir."');
            await animateModelMove(leaoSotao, leaoSotao.position.clone(), new THREE.Vector3(-0.5, 0, 0.5), 1.5);
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('O Sr LeÃ£o se aproxima de vocÃª de forma ameaÃ§adora...');
            await animateModelMove(leaoSotao, leaoSotao.position.clone(), new THREE.Vector3(0, 0, 0), 1.2);
            await new Promise(resolve => setTimeout(resolve, 1500));

            mostrarDialogo('VocÃª se sente ameaÃ§ado e assediado!');
            mostrarEscolhas(['GRITAR POR AJUDA']);
            atualizarInventario();

            const escolha = await aguardarEscolha();
            esconderEscolhas();

            if (escolha === 0) {
                mostrarDialogo('VocÃª GRITA por ajuda: "SOCORRO! ALGUÃ‰M ME AJUDE!"');
                audioManager.playEffect('perigo');
                await new Promise(resolve => setTimeout(resolve, 2000));

                mostrarDialogo('Passos correm escada acima! A porta do sÃ³tÃ£o se abre...');
                await new Promise(resolve => setTimeout(resolve, 2000));

                mostrarDialogo('O Senhor Bode aparece na porta: "O que estÃ¡ acontecendo aqui?!"');
                await new Promise(resolve => setTimeout(resolve, 2000));

                mostrarDialogo('Sr LeÃ£o: "N-nada... EstÃ¡vamos apenas conversando..."');
                await new Promise(resolve => setTimeout(resolve, 2000));

                mostrarDialogo('Senhor Bode: "Saia da minha casa AGORA, Sr LeÃ£o! VocÃª nÃ£o Ã© mais bem-vindo!"');
                audioManager.playEffect('perigo');
                await new Promise(resolve => setTimeout(resolve, 2500));

                mostrarDialogo('O Sr LeÃ£o sai rapidamente, envergonhado. O Senhor Bode se volta para vocÃª:');
                await new Promise(resolve => setTimeout(resolve, 2000));

                mostrarDialogo('"Desculpe por isso. VocÃª estÃ¡ seguro agora. A festa acabou."');
                await new Promise(resolve => setTimeout(resolve, 2000));

                sceneSotao.remove(leaoSotao);
            }
        }

        async function chamada_lobo() {
            gameState.cena_atual = 'chamada_lobo';
            criarCenaCabana();
            const scene = gameState.scene;

            // Primeiro, o jogador ouve batidas na porta
            mostrarDialogo('VocÃª ouve batidas na porta... *Toc, toc, toc*');
            audioManager.playEffect('perigo');
            await new Promise(resolve => setTimeout(resolve, 2000));

            mostrarDialogo('As batidas continuam... AlguÃ©m estÃ¡ do lado de fora.');
            await new Promise(resolve => setTimeout(resolve, 1800));

            // Escolha: ouvir ou nÃ£o o Senhor Lobo
            mostrarDialogo('VocÃª se aproxima da porta. Deve abrir e ver quem estÃ¡ batendo?');
            mostrarEscolhas(['1 - Abrir a porta e ver quem Ã©', '2 - Ignorar e nÃ£o abrir']);
            atualizarInventario();

            const escolhaPorta = await aguardarEscolha();
            await playActionNod(0.3);
            esconderEscolhas();

            if (escolhaPorta === 1) {
                // Jogador escolheu nÃ£o abrir
                mostrarDialogo('VocÃª decide nÃ£o abrir a porta. As batidas param e vocÃª ouve passos se afastando...');
                audioManager.playEffect('passo');
                await new Promise(resolve => setTimeout(resolve, 2000));
                mostrarDialogo('Talvez tenha sido melhor assim. VocÃª continua explorando a casa.');
                await new Promise(resolve => setTimeout(resolve, 1800));
                return false;
            }

            // Jogador escolheu abrir
            mostrarDialogo('VocÃª abre a porta cuidadosamente...');
            await new Promise(resolve => setTimeout(resolve, 1500));

            const lobo = criarModeloLobo();
            // PosiÃ§Ã£o ajustada: porta estÃ¡ em (1.0, 0, -1.9) na cena, lobo deve aparecer na porta
            lobo.scale.set(0.9, 0.9, 0.9);
            lobo.position.set(1.0, 0, -1.9);
            lobo.rotation.y = Math.PI;
            scene.add(lobo);

            const loboLight = new THREE.PointLight(0x7ec6ff, 1.2, 10, 2);
            loboLight.position.set(1.0, 1.8, -1.9);
            scene.add(loboLight);

            const { base, look } = getSceneCameraBase();
            await animateFirstPersonMove([
                {
                    position: base.clone().add(new THREE.Vector3(-0.4, 0.05, -1)),
                    lookAt: look.clone().add(new THREE.Vector3(-0.4, -0.03, -1))
                },
                {
                    position: base.clone(),
                    lookAt: look.clone()
                }
            ], { duration: 2.4, easing: 'easeInOutCubic' });

            audioManager.playEffect('usar');
            mostrarDialogo('O Senhor Lobo surge das sombras: "Chegou a hora. Venha comigo ou ficarÃ¡ preso para sempre."');
            mostrarEscolhas(['1 - Ir com o Senhor Lobo', '2 - Esperar mais um pouco']);
            atualizarInventario();

            const escolha = await aguardarEscolha();
            await playActionNod(escolha === 0 ? 0.5 : 0.25);
            esconderEscolhas();

            scene.remove(lobo);
            scene.remove(loboLight);

            if (escolha === 0) {
                gameState.loboChamou = true;
                audioManager.playEffect('coleta');
                mostrarDialogo('VocÃª decide seguir o Senhor Lobo. Prepare-se para fugir.');
                await new Promise(resolve => setTimeout(resolve, 1800));
                return true;
            } else {
                mostrarDialogo('VocÃª pede mais tempo. O Senhor Lobo desaparece na nÃ©voa, mas promete retornar.');
                await new Promise(resolve => setTimeout(resolve, 1800));
                return false;
            }
        }

        async function explorar() {
            while (true) {
                if (!gameState.bodeNoMercado) {
                    mostrarDialogo('O Senhor Bode ainda estÃ¡ por perto. Espere ele sair para o mercado.');
                    await new Promise((resolve) => setTimeout(resolve, 1800));
                    await aguardar_bode_mercado();
                }

                if (gameState.comodosExplorados >= 2) {
                    mostrarDialogo('VocÃª jÃ¡ explorou dois cÃ´modos. Passos pesados ecoam: o Senhor Bode estÃ¡ voltando!');
                    await new Promise(resolve => setTimeout(resolve, 1400));
                    await bodeRetornaCasa();
                    break;
                }

                criarSalaCasaPrincipal();
                const hubCamera = getSceneCameraBase();
                await animateFirstPersonMove([
                    {
                        position: hubCamera.base.clone().add(new THREE.Vector3(0, 0.02, -0.6)),
                        lookAt: hubCamera.look.clone().add(new THREE.Vector3(0, -0.02, -0.5))
                    },
                    {
                        position: hubCamera.base.clone(),
                        lookAt: hubCamera.look.clone()
                    }
                ], { duration: 1.5 });
                mostrarDialogo('CÃ´modos disponÃ­veis para explorar:');
                mostrarEscolhas([
                    '1 - Cozinha',
                    '2 - Quarto do Senhor Bode',
                    '3 - Biblioteca',
                    '4 - SÃ³tÃ£o',
                    '5 - Banheiro',
                    '6 - Sair da exploraÃ§Ã£o'
                ]);
                atualizarInventario();
                
                const escolha = await aguardarEscolha();
                await playActionNod(0.3);
                esconderEscolhas();

                let explorouComodo = false;
                
                if (escolha === 0) {
                    await cozinha();
                    explorouComodo = true;
                } else if (escolha === 1) {
                    await quarto_sr_bode();
                    explorouComodo = true;
                } else if (escolha === 2) {
                    await biblioteca();
                    explorouComodo = true;
                } else if (escolha === 3) {
                    await sotao();
                    explorouComodo = true;
                } else if (escolha === 4) {
                    await banheiro();
                    explorouComodo = true;
                } else if (escolha === 5) {
                    mostrarDialogo('VocÃª recua antes que seja tarde demais e volta a aguardar outra oportunidade.');
                    await new Promise(resolve => setTimeout(resolve, 1400));
                    await bodeRetornaCasa();
                    break;
                }

                if (explorouComodo) {
                    gameState.comodosExplorados = Math.min(2, gameState.comodosExplorados + 1);
                    if (gameState.comodosExplorados >= 2) {
                        mostrarDialogo('O tempo acabou! VocÃª ouve o rangido da porta: o Senhor Bode estÃ¡ voltando!');
                        await new Promise(resolve => setTimeout(resolve, 1400));
                        await bodeRetornaCasa();
                        break;
                    }
                }
            }
        }

        async function pegar_itens() {
            const opcoes = ['Escopeta', 'SabÃ£o Macaco', 'Comida'];
            const escolhas = [];
            
            while (escolhas.length < 2) {
                criarCenaCabana();
                const hubPickCamera = getSceneCameraBase();
                await animateFirstPersonMove([
                    {
                        position: hubPickCamera.base.clone().add(new THREE.Vector3(0, 0.015, -0.5)),
                        lookAt: hubPickCamera.look.clone().add(new THREE.Vector3(0, -0.015, -0.4))
                    },
                    {
                        position: hubPickCamera.base.clone(),
                        lookAt: hubPickCamera.look.clone()
                    }
                ], { duration: 1.4 });
                
                // Contar quantas comidas jÃ¡ foram escolhidas
                const comidasEscolhidas = escolhas.filter(item => item === 'Comida').length;
                
                // Filtrar opÃ§Ãµes: remover Comida se jÃ¡ tiver 2
                const opcoesDisponiveis = comidasEscolhidas >= 2 
                    ? opcoes.filter(item => item !== 'Comida')
                    : opcoes;
                
                let dialogo = `VocÃª pode pegar 2 itens antes da fuga.\nEscolha mais ${2 - escolhas.length} item(s).`;
                if (escolhas.length > 0) {
                    dialogo += `\nVocÃª jÃ¡ escolheu: ${escolhas.join(', ')}`;
                }
                if (comidasEscolhidas >= 2) {
                    dialogo += `\n(VocÃª jÃ¡ pegou o mÃ¡ximo de 2 comidas)`;
                }
                mostrarDialogo(dialogo);
                mostrarEscolhas(opcoesDisponiveis.map((item, i) => `${i + 1} - ${item}`));
                atualizarInventario();
                
                const escolha = await aguardarEscolha();
                await playActionNod(0.35);
                esconderEscolhas();
                
                if (escolha < opcoesDisponiveis.length) {
                    const item = opcoesDisponiveis[escolha];
                    const comidasAtuais = escolhas.filter(i => i === 'Comida').length;
                    
                    // Verificar se pode pegar o item
                    if (item === 'Comida' && comidasAtuais >= 2) {
                        mostrarDialogo('VocÃª nÃ£o pode pegar mais de 2 comidas!');
                        audioManager.playEffect('perigo');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    } else {
                        // Permitir pegar o item (pode pegar 2 comidas se quiser)
                        escolhas.push(item);
                    }
                }
            }
            
            gameState.inventario.push(...escolhas);
            mostrarDialogo(`VocÃª pegou: ${escolhas.join(', ')}`);
            if (escolhas.length > 0) {
                audioManager.playEffect('coleta');
            }
            atualizarInventario();
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        async function fuga() {
            gameState.cena_atual = 'fuga';
            if (!gameState.loboChamou) {
                mostrarDialogo('Sem o chamado do Senhor Lobo, vocÃª nÃ£o sabe por onde escapar.');
                await new Promise(resolve => setTimeout(resolve, 2000));
                return;
            }
            if (!gameState.bodeNoMercado) {
                mostrarDialogo('O Senhor Bode estÃ¡ em casa! Ã‰ suicÃ­dio tentar fugir agora.');
                audioManager.playEffect('perigo');
                await new Promise(resolve => setTimeout(resolve, 1800));
                return;
            }

            gameState.distancia_cidade = 0;
            gameState.proximidade_sr_bode = 60;

            criarCenaFuga();
            const fugaCamera = getSceneCameraBase();
            mostrarDialogo('A fuga comeÃ§a! A estrada Ã© infinita, sinuosa e tomada pela mesma floresta sinistra do inÃ­cio.');
            await animateFirstPersonMove([
                {
                    position: fugaCamera.base.clone().add(new THREE.Vector3(0, 0.05, -1.3)),
                    lookAt: fugaCamera.look.clone().add(new THREE.Vector3(0, -0.04, -1.2))
                },
                {
                    position: fugaCamera.base.clone(),
                    lookAt: fugaCamera.look.clone()
                }
            ], { duration: 2.4, easing: 'easeInOutCubic' });
            atualizarInventario();
            atualizarStats();
            mostrarEscolhas(['Continuar']);
            await aguardarEscolha();
            await playActionNod(0.35);
            esconderEscolhas();

            gameState.fome = 100;
            gameState.lastCansacoSound = 0;
            atualizarStats();

            const obterTempo = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            const verificarCansaco = () => {
                if (gameState.fome < 40) {
                    const agora = obterTempo();
                    if (!gameState.lastCansacoSound || agora - gameState.lastCansacoSound > 6000) {
                        audioManager.playEffect('cansado');
                        gameState.lastCansacoSound = agora;
                    }
                }
            };
            const consumirFome = (quantidade) => {
                gameState.fome = Math.max(0, gameState.fome - quantidade);
                verificarCansaco();
            };

            // Morte quando proximidade do bode chegar a 0 (ele te alcanÃ§a)
            const capturaLimite = 0;
            let capturado = false;
            let resgatado = false;

            // Criar cena uma vez antes do loop para evitar tela preta
                criarCenaFuga();
            
            while (true) {
                // NÃ£o recriar a cena a cada loop para evitar tela preta
                const distanciaAteCidade = Math.max(0, Math.round(220 - gameState.distancia_cidade));
                mostrarDialogo(`DistÃ¢ncia atÃ© a cidade: ${distanciaAteCidade}  |  DistÃ¢ncia do Sr Bode: ${Math.round(gameState.proximidade_sr_bode)}\nEscolha sua aÃ§Ã£o:`);
                mostrarEscolhas([
                    '1 - Correr rÃ¡pido',
                    '2 - Correr devagar',
                    '3 - Usar item',
                    '4 - Parar/Explorar'
                ]);
                atualizarInventario();
                atualizarStats();

                const escolha = await aguardarEscolha();
                await playActionNod(0.3);
                esconderEscolhas();
                const hungerFactor = Math.max(0.35, gameState.fome / 100);

                if (escolha === 0) {
                    const ganho = Math.max(8, Math.round(14 * hungerFactor));
                    gameState.distancia_cidade += ganho;
                    // Quando vocÃª corre rÃ¡pido, o Senhor Bode Ã© mais rÃ¡pido, mas um pouco mais lento
                    // Ele se aproxima: 80% do que vocÃª avanÃ§a + 1 (sempre um pouco mais rÃ¡pido, mas mais lento)
                    gameState.proximidade_sr_bode = Math.max(0, gameState.proximidade_sr_bode - Math.round(ganho * 0.8 + 1));
                    mostrarDialogo('VocÃª dispara floresta adentro, mas o Senhor Bode ainda te persegue de perto!');
                    audioManager.playEffect('passo');
                    consumirFome(14);
                } else if (escolha === 1) {
                    const ganho = Math.max(5, Math.round(9 * hungerFactor));
                    gameState.distancia_cidade += ganho;
                    // Quando vocÃª corre devagar, o Senhor Bode se aproxima mais rÃ¡pido, mas um pouco mais lento
                    // Ele se aproxima: 70% do que vocÃª avanÃ§a + 2 (mais rÃ¡pido que vocÃª, mas mais lento)
                    gameState.proximidade_sr_bode = Math.max(0, gameState.proximidade_sr_bode - Math.round(ganho * 0.7 + 2));
                    mostrarDialogo('VocÃª mantÃ©m um ritmo constante, mas o Senhor Bode se aproxima gradualmente...');
                    consumirFome(9);
                } else if (escolha === 2) {
                    if (gameState.inventario.length > 0) {
                        criarCenaFuga();
                        mostrarDialogo('Escolha um item para usar:');
                        mostrarEscolhas(gameState.inventario);
                        atualizarInventario();
                        atualizarStats();

                        const itemEscolha = await aguardarEscolha();
                        await playActionNod(0.25);
                        esconderEscolhas();

                        if (itemEscolha < gameState.inventario.length) {
                            const item = gameState.inventario[itemEscolha];

                            if (item === 'Escopeta') {
                                mostrarDialogo('VocÃª dispara a escopeta, mas os tiros atravessam o Senhor Bode sem efeito!');
                                audioManager.playEffect('escopeta');
                            } else if (item === 'Comida') {
                                gameState.distancia_cidade += 18;
                                mostrarDialogo('VocÃª se alimenta com pressa e ganha fÃ´lego para correr ainda mais.');
                                audioManager.playEffect('coleta');
                                setPlayerState('run');
                                // Restaura 80% da fome (80 pontos de 100)
                                gameState.fome = Math.min(100, gameState.fome + 80);
                                gameState.lastCansacoSound = obterTempo();
                            } else if (item === 'SabÃ£o Macaco') {
                                mostrarDialogo('VocÃª lanÃ§a o SabÃ£o Macaco! O Senhor Bode escorrega longe na lama sinistra, sumindo na nÃ©voa por alguns instantes!');
                                audioManager.playEffect('usar');
                                // SabÃ£o Macaco afasta o Bode, mas ele ainda se aproxima depois
                                gameState.proximidade_sr_bode = Math.max(0, gameState.proximidade_sr_bode + 50);
                                gameState.distancia_cidade += 28;
                            }

                            const index = gameState.inventario.indexOf(item);
                            if (index > -1) {
                                gameState.inventario.splice(index, 1);
                            }
                        }
                    } else {
                        mostrarDialogo('VocÃª nÃ£o tem itens disponÃ­veis!');
                        audioManager.playEffect('perigo');
                    }
                    consumirFome(6);
                } else if (escolha === 3) {
                    gameState.distancia_cidade = Math.max(0, gameState.distancia_cidade - 6);
                    // Quando vocÃª para, o Bode se aproxima, mas um pouco mais lento
                    gameState.proximidade_sr_bode = Math.max(0, gameState.proximidade_sr_bode - 10);
                    mostrarDialogo('VocÃª hesita e o Senhor Bode se aproxima rapidamente!');
                    audioManager.playEffect('perigo');
                    consumirFome(5);
                }

                // PressÃ£o constante do Bode: ele sempre se aproxima moderadamente, um pouco mais lento
                // Mesmo sem aÃ§Ã£o do jogador, ele se aproxima continuamente
                const pressaoBode = 2 + Math.min(5, gameState.distancia_cidade / 45);
                gameState.proximidade_sr_bode = Math.max(0, gameState.proximidade_sr_bode - pressaoBode);

                atualizarInventario();
                atualizarStats();
                await new Promise(resolve => setTimeout(resolve, 500));

                // Verificar vitÃ³ria primeiro (antes das condiÃ§Ãµes de morte)
                const distanciaAteCidadeFinal = 220 - gameState.distancia_cidade;
                // Quando a distÃ¢ncia atÃ© a cidade chega a 0, comeÃ§a a luta
                if (distanciaAteCidadeFinal <= 0) {
                    resgatado = true;
                    break;
                }

                // CondiÃ§Ãµes de morte: fome chega a 0 OU proximidade do bode chega a 0 (ele te alcanÃ§a)
                if (gameState.fome <= 0) {
                    capturado = true;
                    break;
                }

                if (gameState.proximidade_sr_bode <= capturaLimite) {
                    capturado = true;
                    break;
                }
            }

            criarCenaFuga();
            if (capturado) {
                let mensagemMorte = 'O Senhor Bode te alcanÃ§a! A fuga infinita termina em escuridÃ£o absoluta...';
                if (gameState.fome <= 0) {
                    mensagemMorte = 'Sua fome chegou a zero! VocÃª desmaia de exaustÃ£o e o Senhor Bode te alcanÃ§a...';
                } else if (gameState.proximidade_sr_bode <= capturaLimite) {
                    mensagemMorte = 'O Senhor Bode te alcanÃ§ou completamente! NÃ£o hÃ¡ mais como escapar...';
                }
                audioManager.playEffect('perigo');
                setAmbient(null);
                setPlayerState('alerta');
                await new Promise(resolve => setTimeout(resolve, 1500));
                mostrarTelaMorte(mensagemMorte);
            } else if (resgatado) {
                mostrarDialogo('Depois de correr por uma eternidade, vocÃª finalmente chega Ã  cidade!');
                audioManager.playEffect('coleta');
                setAmbient(null);
                setPlayerState('idle');
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                try {
                    await lutarBodeCavalo();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    mostrarTelaVitoria();
                } catch (error) {
                    console.error('Erro na luta:', error);
                    mostrarTelaVitoria();
                }
            }
            atualizarStats();
        }

        // Iniciar jogo - expor no window para acesso global
        window.startGame = async function startGame() {
            if (gameState.isRunning) return;
            resetGameProgress();
            gameState.isRunning = true;

            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('death-screen').classList.add('hidden');
            document.getElementById('victory-screen').classList.add('hidden');
            document.getElementById('ui-container').style.display = 'block';
            initThreeJS();
            await audioManager.resume();
            gameState.audioUnlocked = audioManager.unlocked;
            setAmbient(null);
            setPlayerState('idle');
            atualizarInventario();
            atualizarStats();
            
            if (await floresta()) {
                await cabana();
                await aguardar_bode_mercado();
                let loboAceitou = false;
                while (!loboAceitou) {
                    await explorar();
                    const chamadaAceita = await chamada_lobo();
                    if (chamadaAceita) {
                        loboAceitou = true;
                        await aguardar_bode_mercado();
                    } else {
                        mostrarDialogo('VocÃª prefere esperar mais um pouco antes de fugir...');
                        await new Promise(resolve => setTimeout(resolve, 1800));
                        await aguardar_bode_mercado();
                    }
                }
                await pegar_itens();
                await fuga();
            }

            gameState.isRunning = false;
        }

        // Ajustar canvas ao redimensionar
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            if (gameState.camera && gameState.renderer) {
                gameState.camera.aspect = container.offsetWidth / (container.offsetHeight * 0.6);
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(container.offsetWidth, container.offsetHeight * 0.6);
            }
        });
    </script>
</body>
</html>

